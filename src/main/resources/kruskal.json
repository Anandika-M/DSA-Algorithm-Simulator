{
  "algorithm": {
    "id": "kruskal_algorithm",
    "name": "Kruskal's Algorithm",
    "category": "Graph Algorithms / Minimum Spanning Tree",
    "description": "A greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It works by sorting all edges and adding them to the tree in increasing weight order, avoiding cycles."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're building a road network to connect several towns with minimum total road construction cost. You start by listing all possible roads between towns with their construction costs. You begin building the cheapest roads first, but you skip any road that would create a loop (since towns are already connected). You continue this process until all towns are connected with the minimum total cost, creating an efficient network without unnecessary connections."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Kruskal's algorithm finds the Minimum Spanning Tree (MST) of a connected, undirected graph with weighted edges. The MST is a subset of edges that connects all vertices without any cycles and with minimum possible total edge weight.\n\n**Key Idea:** Sort all edges by weight, then process them from smallest to largest. Add an edge to the MST if it doesn't form a cycle. Use Union-Find data structure to efficiently check for cycles."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Kruskal\"] --> B[\"Initialize:\n- MST as empty set\n- Sort all edges by weight\n- Initialize Union-Find\"]\n    B --> C[\"For each edge in sorted order\"]\n    C --> D{\"Does edge u,v form cycle?\nFindu == Findv?\"}\n    D -->|No| E[\"Add edge to MST\nUnionu, v in Union-Find\"]\n    D -->|Yes| F[\"Skip this edge\"]\n    E --> G{\"MST has V-1 edges?\"}\n    F --> G\n    G -->|No| C\n    G -->|Yes| H[\"Return MST\"]\n    H --> I[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Graph:**\n```\n        (A)\n       / | \\\n      1  3  4\n     /   |   \\\n   (B)   |   (C)\n    |    2    |\n    4    |    5\n    |    |    |\n   (D)---6---(E)\n```\n\n**Edges sorted by weight:**\n1. A-B: 1\n2. C-E: 2\n3. A-C: 3\n4. B-D: 4\n5. A-D: 4\n6. C-D: 5\n7. D-E: 6\n\n**MST Construction:**\n\n| Step | Edge | Weight | Action | MST Edges | Components |\n|------|------|--------|--------|-----------|------------|\n| 1 | A-B | 1 | Add | A-B | {A,B}, {C}, {D}, {E} |\n| 2 | C-E | 2 | Add | A-B, C-E | {A,B}, {C,E}, {D} |\n| 3 | A-C | 3 | Add | A-B, C-E, A-C | {A,B,C,E}, {D} |\n| 4 | B-D | 4 | Add | A-B, C-E, A-C, B-D | {A,B,C,D,E} |\n\n**MST Complete** (V-1 = 4 edges for 5 vertices)\n\n**Final MST:** A-B (1), C-E (2), A-C (3), B-D (4)\n**Total Weight:** 1 + 2 + 3 + 4 = 10\n\n**MST Visualization:**\n```\n    (A)\n   /   \\\n  1     3\n /       \\\n(B)     (C)\n |       |\n 4       2\n |       |\n(D)     (E)\n```"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(E log E)** or **O(E log V)** - due to edge sorting\n- **O(E α(V))** - with Union-Find operations (α is inverse Ackermann)\n\n### Space Complexity:\n- **O(V + E)** - for storing graph and Union-Find structure\n\n### Requirements:\n- **Undirected graph**\n- **Connected graph** (or finds MST for each connected component)\n- **Weighted edges**\n\n### Optimality:\n- **Yes** - always finds minimum spanning tree\n\n### When to Use Kruskal's Algorithm:\n\n**✅ Suitable for:**\n- Sparse graphs (E ≈ V)\n- Network design (telecom, roads, circuits)\n- Cluster analysis\n- Image segmentation\n- Approximation algorithms for NP-hard problems\n\n**❌ Not suitable for:**\n- Dense graphs (E ≈ V²) - Prim's might be better\n- Dynamic graphs where edges change frequently\n- When you need the MST rooted at specific node\n\n### Variations:\n1. **Reverse-delete Algorithm** - start with all edges, remove largest\n2. **Filter-Kruskal** - optimization for certain graph types\n3. **Parallel Kruskal** - for distributed systems\n\n### Optimization Tips:\n1. **Use efficient Union-Find** with path compression and union by rank\n2. **Stop early** when V-1 edges are selected\n3. **Use counting sort** if edge weights have limited range\n4. **Process edges in batches** for very large graphs\n\n### Common Applications:\n1. **Network Design** - telephone, computer, road networks\n2. **Cluster Analysis** - grouping similar data points\n3. **Image Processing** - image segmentation\n4. **Circuit Design** - connecting pins with minimum wire\n5. **Approximation Algorithms** - TSP, Steiner tree\n6. **Biology** - phylogenetic trees construction"
    }
  ],
  "code_examples": {
    "python": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n    \n    def union(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        \n        if root_x == root_y:\n            return False  # Already connected\n        \n        # Union by rank\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        \n        return True\n\ndef kruskal(n, edges):\n    \"\"\"\n    n: number of vertices\n    edges: list of (weight, u, v)\n    returns: (mst_edges, total_weight)\n    \"\"\"\n    # Sort edges by weight\n    edges.sort()\n    \n    uf = UnionFind(n)\n    mst_edges = []\n    total_weight = 0\n    \n    for weight, u, v in edges:\n        if uf.union(u, v):\n            mst_edges.append((u, v, weight))\n            total_weight += weight\n            \n            # Stop early if we have V-1 edges\n            if len(mst_edges) == n - 1:\n                break\n    \n    return mst_edges, total_weight\n\n# Example usage\nif __name__ == \"__main__\":\n    # Graph: 5 vertices (0=A, 1=B, 2=C, 3=D, 4=E)\n    n = 5\n    edges = [\n        (1, 0, 1),  # A-B: 1\n        (3, 0, 2),  # A-C: 3\n        (4, 0, 3),  # A-D: 4\n        (4, 1, 3),  # B-D: 4\n        (2, 2, 4),  # C-E: 2\n        (5, 2, 3),  # C-D: 5\n        (6, 3, 4),  # D-E: 6\n    ]\n    \n    mst_edges, total_weight = kruskal(n, edges)\n    \n    print(\"MST Edges:\")\n    for u, v, weight in mst_edges:\n        print(f\"{u}-{v}: {weight}\")\n    print(f\"Total weight: {total_weight}\")",
    "javascript": "class UnionFind {\n    constructor(n) {\n        this.parent = Array.from({length: n}, (_, i) => i);\n        this.rank = Array(n).fill(0);\n    }\n    \n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]); // Path compression\n        }\n        return this.parent[x];\n    }\n    \n    union(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        \n        if (rootX === rootY) return false; // Already connected\n        \n        // Union by rank\n        if (this.rank[rootX] < this.rank[rootY]) {\n            this.parent[rootX] = rootY;\n        } else if (this.rank[rootX] > this.rank[rootY]) {\n            this.parent[rootY] = rootX;\n        } else {\n            this.parent[rootY] = rootX;\n            this.rank[rootX]++;\n        }\n        \n        return true;\n    }\n}\n\nfunction kruskal(n, edges) {\n    // Sort edges by weight\n    edges.sort((a, b) => a[0] - b[0]);\n    \n    const uf = new UnionFind(n);\n    const mstEdges = [];\n    let totalWeight = 0;\n    \n    for (const [weight, u, v] of edges) {\n        if (uf.union(u, v)) {\n            mstEdges.push([u, v, weight]);\n            totalWeight += weight;\n            \n            // Stop early if we have V-1 edges\n            if (mstEdges.length === n - 1) break;\n        }\n    }\n    \n    return [mstEdges, totalWeight];\n}\n\n// Example usage\nconst n = 5;\nconst edges = [\n    [1, 0, 1],  // A-B: 1\n    [3, 0, 2],  // A-C: 3\n    [4, 0, 3],  // A-D: 4\n    [4, 1, 3],  // B-D: 4\n    [2, 2, 4],  // C-E: 2\n    [5, 2, 3],  // C-D: 5\n    [6, 3, 4],  // D-E: 6\n];\n\nconst [mstEdges, totalWeight] = kruskal(n, edges);\n\nconsole.log(\"MST Edges:\");\nmstEdges.forEach(([u, v, weight]) => {\n    console.log(`${u}-${v}: ${weight}`);\n});\nconsole.log(`Total weight: ${totalWeight}`);",
    "java": "import java.util.*;\n\npublic class Kruskal {\n    static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]); // Path compression\n            }\n            return parent[x];\n        }\n        \n        public boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return false; // Already connected\n            \n            // Union by rank\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    public static List<int[]> kruskal(int n, List<int[]> edges) {\n        // Sort edges by weight\n        edges.sort((a, b) -> Integer.compare(a[0], b[0]));\n        \n        UnionFind uf = new UnionFind(n);\n        List<int[]> mstEdges = new ArrayList<>();\n        int totalWeight = 0;\n        \n        for (int[] edge : edges) {\n            int weight = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            \n            if (uf.union(u, v)) {\n                mstEdges.add(new int[]{u, v, weight});\n                totalWeight += weight;\n                \n                // Stop early if we have V-1 edges\n                if (mstEdges.size() == n - 1) break;\n            }\n        }\n        \n        System.out.println(\"Total MST weight: \" + totalWeight);\n        return mstEdges;\n    }\n    \n    public static void main(String[] args) {\n        int n = 5;\n        List<int[]> edges = new ArrayList<>();\n        edges.add(new int[]{1, 0, 1});  // A-B: 1\n        edges.add(new int[]{3, 0, 2});  // A-C: 3\n        edges.add(new int[]{4, 0, 3});  // A-D: 4\n        edges.add(new int[]{4, 1, 3});  // B-D: 4\n        edges.add(new int[]{2, 2, 4});  // C-E: 2\n        edges.add(new int[]{5, 2, 3});  // C-D: 5\n        edges.add(new int[]{6, 3, 4});  // D-E: 6\n        \n        List<int[]> mstEdges = kruskal(n, edges);\n        \n        System.out.println(\"MST Edges:\");\n        for (int[] edge : mstEdges) {\n            System.out.println(edge[0] + \"-\" + edge[1] + \": \" + edge[2]);\n        }\n    }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    \npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return false; // Already connected\n        \n        // Union by rank\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        return true;\n    }\n};\n\nvector<vector<int>> kruskal(int n, vector<vector<int>>& edges) {\n    // Sort edges by weight\n    sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n    \n    UnionFind uf(n);\n    vector<vector<int>> mstEdges;\n    int totalWeight = 0;\n    \n    for (auto& edge : edges) {\n        int weight = edge[0];\n        int u = edge[1];\n        int v = edge[2];\n        \n        if (uf.unite(u, v)) {\n            mstEdges.push_back({u, v, weight});\n            totalWeight += weight;\n            \n            // Stop early if we have V-1 edges\n            if (mstEdges.size() == n - 1) break;\n        }\n    }\n    \n    cout << \"Total MST weight: \" << totalWeight << endl;\n    return mstEdges;\n}\n\nint main() {\n    int n = 5;\n    vector<vector<int>> edges = {\n        {1, 0, 1},  // A-B: 1\n        {3, 0, 2},  // A-C: 3\n        {4, 0, 3},  // A-D: 4\n        {4, 1, 3},  // B-D: 4\n        {2, 2, 4},  // C-E: 2\n        {5, 2, 3},  // C-D: 5\n        {6, 3, 4}   // D-E: 6\n    };\n    \n    vector<vector<int>> mstEdges = kruskal(n, edges);\n    \n    cout << \"MST Edges:\" << endl;\n    for (auto& edge : mstEdges) {\n        cout << edge[0] << \"-\" << edge[1] << \": \" << edge[2] << endl;\n    }\n    \n    return 0;\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["graph", "minimum-spanning-tree", "greedy", "union-find", "sorting"]
  }
}