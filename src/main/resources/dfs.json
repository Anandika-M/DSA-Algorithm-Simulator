{
  "algorithm": {
    "id": "depth_first_search",
    "name": "Depth-First Search",
    "category": "Graph Algorithms",
    "description": "A graph traversal algorithm that explores as far as possible along each branch before backtracking. Uses a stack data structure (either explicitly or via recursion)."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're exploring a maze. Instead of checking all paths at each intersection, you choose one path and follow it as far as you can until you hit a dead end. When you reach a dead end, you backtrack to the last intersection and try a different path. You keep going deeper and deeper down each path before considering alternatives, which might help you find exits deep in the maze quickly."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Depth-First Search is a graph traversal algorithm that explores vertices by going deeper and deeper along each branch before backtracking. It uses a stack data structure (either explicitly or through recursion) to keep track of vertices to visit.\n\n**Key Idea:** Explore as far as possible along each branch before backtracking. This approach is memory efficient but doesn't guarantee the shortest path."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start DFS\"] --> B[\"Push start node to stack\nOR make recursive call\"]\n    B --> C[\"Mark node as visited\"]\n    C --> D[\"Process current node\"]\n    D --> E{\"Any unvisited neighbors?\"}\n    E -->|Yes| F[\"Push neighbor to stack\nOR recursively call DFS\"]\n    F --> C\n    E -->|No| G[\"Backtrack (pop from stack)\nOR return from recursion\"]\n    G --> H{\"Stack empty?\nAll nodes visited?\"}\n    H -->|No| E\n    H -->|Yes| I[\"Traversal complete\"]\n    I --> J[\"End\"]\n```"
       },
    {
      "id": "example",
      "label": "Example Traversal",
      "content": "**Graph:**\n```\n    A\n   / \\\n  B   C\n /   / \\\nD   E   F\n```\n\n**DFS Traversal starting from A (assuming alphabetical order):**\n1. Start at A\n2. Go to B (first neighbor)\n3. Go to D (only neighbor of B)\n4. Backtrack to B (no more neighbors)\n5. Backtrack to A\n6. Go to C (next neighbor of A)\n7. Go to E (first neighbor of C)\n8. Backtrack to C\n9. Go to F (next neighbor of C)\n\n**Final Traversal Order:** A → B → D → C → E → F\n\n**Stack States (Iterative):**\n- Start: [A]\n- Process A: [B, C]\n- Process B: [D, C]\n- Process D: [C]\n- Process C: [E, F]\n- Process E: [F]\n- Process F: []"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(V + E)** - where V is vertices, E is edges\n- **O(b^m)** - in tree search, where b is branching factor, m is maximum depth\n\n### Space Complexity:\n- **O(V)** - for storing visited nodes and recursion stack\n- **O(d)** - in tree search, where d is depth (memory efficient)\n\n### Completeness:\n- **No** for infinite graphs - may get stuck in infinite depth\n- **Yes** for finite graphs\n\n### Optimality:\n- **No** - doesn't guarantee shortest path\n\n### When to Use DFS:\n\n**✅ Suitable for:**\n- Path finding (when any path suffices)\n- Cycle detection\n- Topological sorting\n- Solving puzzles and mazes\n- Finding connected components\n- Memory-constrained environments\n- Game solving algorithms\n\n**❌ Not suitable for:**\n- Finding shortest path in unweighted graphs\n- Very broad graphs with infinite depth\n- When solution is at shallow depth\n\n### Common Applications:\n1. **Maze Solving** - exploring all possible paths\n2. **Cycle Detection** in directed graphs\n3. **Topological Sorting** of DAGs\n4. **Solving Puzzles** like Sudoku, N-queens\n5. **Path Finding** when any path is acceptable\n6. **Connected Components** in undirected graphs\n\n### Variations:\n1. **Pre-order DFS** - process node before neighbors\n2. **Post-order DFS** - process node after neighbors\n3. **In-order DFS** - for binary trees (left, node, right)\n\n### Implementation Tips:\n1. **Use recursion** for simplicity or **explicit stack** for large graphs\n2. **Maintain visited set** to avoid cycles\n3. **Track discovery/finish times** for advanced applications\n4. **Consider iterative deepening** for depth-limited search\n5. **Use backtracking** for constraint satisfaction problems"
    }
  ],
  "code_examples": {
    "python": "def dfs_recursive(graph, node, visited=None, result=None):\n    if visited is None:\n        visited = set()\n    if result is None:\n        result = []\n    \n    visited.add(node)\n    result.append(node)\n    \n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited, result)\n    \n    return result\n\ndef dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    result = []\n    \n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            # Add neighbors in reverse to maintain order\n            for neighbor in reversed(graph[node]):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return result\n\n# Example usage\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'E', 'F'],\n    'D': ['B'],\n    'E': ['C'],\n    'F': ['C']\n}\n\nprint(dfs_recursive(graph, 'A'))  # ['A', 'B', 'D', 'C', 'E', 'F']\nprint(dfs_iterative(graph, 'A'))  # ['A', 'B', 'D', 'C', 'E', 'F']",
    "javascript": "function dfsRecursive(graph, node, visited = new Set(), result = []) {\n    visited.add(node);\n    result.push(node);\n    \n    for (const neighbor of graph[node]) {\n        if (!visited.has(neighbor)) {\n            dfsRecursive(graph, neighbor, visited, result);\n        }\n    }\n    \n    return result;\n}\n\nfunction dfsIterative(graph, start) {\n    const visited = new Set();\n    const stack = [start];\n    const result = [];\n    \n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (!visited.has(node)) {\n            visited.add(node);\n            result.push(node);\n            // Add neighbors in reverse to maintain order\n            for (let i = graph[node].length - 1; i >= 0; i--) {\n                const neighbor = graph[node][i];\n                if (!visited.has(neighbor)) {\n                    stack.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\nconst graph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'E', 'F'],\n    'D': ['B'],\n    'E': ['C'],\n    'F': ['C']\n};\n\nconsole.log(dfsRecursive(graph, 'A'));  // ['A', 'B', 'D', 'C', 'E', 'F']\nconsole.log(dfsIterative(graph, 'A'));  // ['A', 'B', 'D', 'C', 'E', 'F']",
    "java": "import java.util.*;\n\npublic class DFS {\n    public static List<String> dfsRecursive(Map<String, List<String>> graph, String start) {\n        List<String> result = new ArrayList<>();\n        Set<String> visited = new HashSet<>();\n        dfsHelper(graph, start, visited, result);\n        return result;\n    }\n    \n    private static void dfsHelper(Map<String, List<String>> graph, String node, \n                                 Set<String> visited, List<String> result) {\n        visited.add(node);\n        result.add(node);\n        \n        for (String neighbor : graph.get(node)) {\n            if (!visited.contains(neighbor)) {\n                dfsHelper(graph, neighbor, visited, result);\n            }\n        }\n    }\n    \n    public static List<String> dfsIterative(Map<String, List<String>> graph, String start) {\n        Set<String> visited = new HashSet<>();\n        Stack<String> stack = new Stack<>();\n        List<String> result = new ArrayList<>();\n        \n        stack.push(start);\n        \n        while (!stack.isEmpty()) {\n            String node = stack.pop();\n            if (!visited.contains(node)) {\n                visited.add(node);\n                result.add(node);\n                for (int i = graph.get(node).size() - 1; i >= 0; i--) {\n                    String neighbor = graph.get(node).get(i);\n                    if (!visited.contains(neighbor)) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
    "cpp": "#include <iostream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nvoid dfsHelper(unordered_map<string, vector<string>>& graph, string node,\n               unordered_set<string>& visited, vector<string>& result) {\n    visited.insert(node);\n    result.push_back(node);\n    \n    for (string neighbor : graph[node]) {\n        if (visited.find(neighbor) == visited.end()) {\n            dfsHelper(graph, neighbor, visited, result);\n        }\n    }\n}\n\nvector<string> dfsRecursive(unordered_map<string, vector<string>>& graph, string start) {\n    unordered_set<string> visited;\n    vector<string> result;\n    dfsHelper(graph, start, visited, result);\n    return result;\n}\n\nvector<string> dfsIterative(unordered_map<string, vector<string>>& graph, string start) {\n    unordered_set<string> visited;\n    stack<string> st;\n    vector<string> result;\n    \n    st.push(start);\n    \n    while (!st.empty()) {\n        string node = st.top();\n        st.pop();\n        \n        if (visited.find(node) == visited.end()) {\n            visited.insert(node);\n            result.push_back(node);\n            \n            for (int i = graph[node].size() - 1; i >= 0; i--) {\n                string neighbor = graph[node][i];\n                if (visited.find(neighbor) == visited.end()) {\n                    st.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    return result;\n}"
  },
  "metadata": {
    "difficulty": "Beginner",
    "last_updated": "2024-01-15",
    "tags": ["graph", "traversal", "stack", "recursion", "backtracking"]
  }
}