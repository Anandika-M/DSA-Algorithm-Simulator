{
  "algorithm": {
    "id": "longest_common_subsequence",
    "name": "Longest Common Subsequence",
    "category": "Dynamic Programming",
    "description": "Finds the longest subsequence common to two sequences. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguously."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're comparing two books to find the longest common storyline. The characters and events don't have to appear in exactly the same chapters or pages, but they must appear in the same order in both books. You're looking for the longest sequence of plot points that both books share in the same sequence, even if there are other events in between."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "The Longest Common Subsequence problem finds the longest sequence that appears in the same order in both input sequences. Unlike substrings, subsequences don't need to be contiguous.\n\n**Key Idea:** Use dynamic programming where dp[i][j] represents the length of LCS of the first i characters of string1 and first j characters of string2. The solution builds up from smaller subproblems."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start LCS\"] --> B[\"Create DP table m+1 × n+1\nInitialize first row & column to 0\"]\n    B --> C[\"For i from 1 to m\nFor j from 1 to n\"]\n    C --> D{\"str1[i-1] == str2[j-1]?\"}\n    D -->|Yes| E[\"Characters match:\ndpi,j = dpi-1,j-1 + 1\"]\n    D -->|No| F[\"Characters don't match:\ndpi,j = max dpi-1,j, dpi,j-1\"]\n    E --> G{\"More cells?\"}\n    F --> G\n    G -->|Yes| C\n    G -->|No| H[\"dpm,n contains LCS length\"]\n    H --> I[\"Backtrack to reconstruct LCS string\"]\n    I --> J[\"Return LCS length and string\"]\n    J --> K[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Input Strings:**\n- String 1: \"ABCDGH\"\n- String 2: \"AEDFHR\"\n\n**DP Table Construction:**\n\n|   | '' | A | E | D | F | H | R |\n|---|----|---|---|---|---|---|---|\n| ''| 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| A | 0 | 1 | 1 | 1 | 1 | 1 | 1 |\n| B | 0 | 1 | 1 | 1 | 1 | 1 | 1 |\n| C | 0 | 1 | 1 | 1 | 1 | 1 | 1 |\n| D | 0 | 1 | 1 | 2 | 2 | 2 | 2 |\n| G | 0 | 1 | 1 | 2 | 2 | 2 | 2 |\n| H | 0 | 1 | 1 | 2 | 2 | 3 | 3 |\n\n**LCS Length:** 3 (from bottom-right cell)\n\n**LCS String Reconstruction (Backtracking):**\n- Start from dp[6][6] = 3\n- Move diagonally when characters match\n- \"A\" (match) → \"D\" (match) → \"H\" (match)\n- **LCS: \"ADH\"**\n\n**Explanation:** \"A\", \"D\", \"H\" appear in both strings in the same order:\n- \"ABCDGH\" has A, D, H at positions 1, 4, 6\n- \"AEDFHR\" has A, D, H at positions 1, 3, 5"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(m×n)** - where m and n are lengths of input strings\n- **O(min(m,n))** - space optimized version\n\n### Space Complexity:\n- **O(m×n)** - for full DP table\n- **O(min(m,n))** - optimized with two rows\n\n### Problem Type:\n- **Dynamic Programming**\n- **String Algorithm**\n- **Sequence Alignment**\n\n### When to Use LCS:\n\n**✅ Suitable for:**\n- DNA sequence alignment\n- Version control systems (diff algorithms)\n- Plagiarism detection\n- Speech recognition\n- File comparison tools\n- Bioinformatics\n\n**❌ Not suitable for:**\n- Very long sequences (billions of characters)\n- Real-time applications with large inputs\n- When contiguous matching is required (use longest common substring)\n\n### Variations:\n1. **Longest Common Substring** - contiguous subsequence\n2. **Longest Increasing Subsequence** - within single sequence\n3. **Edit Distance** - minimum operations to transform strings\n4. **Multiple Sequence Alignment** - more than two sequences\n\n### Optimization Tips:\n1. **Use 2-row DP table** to reduce space complexity\n2. **Hirschberg's algorithm** for O(min(m,n)) space\n3. **Bit-parallel algorithm** for certain cases\n4. **Four Russians technique** for theoretical improvement\n\n### Common Applications:\n1. **Bioinformatics** - DNA, protein sequence alignment\n2. **Version Control** - git diff, file comparison\n3. **Plagiarism Detection** - document similarity\n4. **Speech Recognition** - matching spoken words\n5. **Data Deduplication** - finding similar records\n6. **Natural Language Processing** - text similarity"
    }
  ],
  "code_examples": {
    "python": "def lcs_length(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]\n\ndef lcs_string(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Reconstruct LCS string\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i-1] == str2[j-1]:\n            lcs.append(str1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))\n\n# Space optimized version\ndef lcs_optimized(str1, str2):\n    if len(str1) < len(str2):\n        str1, str2 = str2, str1  # Ensure str2 is shorter\n    \n    m, n = len(str1), len(str2)\n    prev = [0] * (n + 1)\n    curr = [0] * (n + 1)\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                curr[j] = prev[j-1] + 1\n            else:\n                curr[j] = max(prev[j], curr[j-1])\n        prev, curr = curr, prev\n    \n    return prev[n]\n\n# Example usage\nstr1 = \"ABCDGH\"\nstr2 = \"AEDFHR\"\nprint(f\"LCS Length: {lcs_length(str1, str2)}\")      # Output: 3\nprint(f\"LCS String: {lcs_string(str1, str2)}\")      # Output: \"ADH\"\nprint(f\"LCS Optimized: {lcs_optimized(str1, str2)}\") # Output: 3",
    "javascript": "function lcsLength(str1, str2) {\n    const m = str1.length, n = str2.length;\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (str1[i-1] === str2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\nfunction lcsString(str1, str2) {\n    const m = str1.length, n = str2.length;\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n    \n    // Build DP table\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (str1[i-1] === str2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    // Reconstruct LCS string\n    const lcs = [];\n    let i = m, j = n;\n    while (i > 0 && j > 0) {\n        if (str1[i-1] === str2[j-1]) {\n            lcs.push(str1[i-1]);\n            i--;\n            j--;\n        } else if (dp[i-1][j] > dp[i][j-1]) {\n            i--;\n        } else {\n            j--;\n        }\n    }\n    \n    return lcs.reverse().join('');\n}\n\n// Space optimized version\nfunction lcsOptimized(str1, str2) {\n    if (str1.length < str2.length) {\n        [str1, str2] = [str2, str1]; // Ensure str2 is shorter\n    }\n    \n    const m = str1.length, n = str2.length;\n    let prev = Array(n + 1).fill(0);\n    let curr = Array(n + 1).fill(0);\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (str1[i-1] === str2[j-1]) {\n                curr[j] = prev[j-1] + 1;\n            } else {\n                curr[j] = Math.max(prev[j], curr[j-1]);\n            }\n        }\n        [prev, curr] = [curr, prev];\n    }\n    \n    return prev[n];\n}\n\n// Example usage\nconst str1 = \"ABCDGH\";\nconst str2 = \"AEDFHR\";\nconsole.log(`LCS Length: ${lcsLength(str1, str2)}`);      // Output: 3\nconsole.log(`LCS String: ${lcsString(str1, str2)}`);      // Output: \"ADH\"\nconsole.log(`LCS Optimized: ${lcsOptimized(str1, str2)}`); // Output: 3",
    "java": "import java.util.*;\n\npublic class LCS {\n    public static int lcsLength(String str1, String str2) {\n        int m = str1.length(), n = str2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (str1.charAt(i-1) == str2.charAt(j-1)) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    public static String lcsString(String str1, String str2) {\n        int m = str1.length(), n = str2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Build DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (str1.charAt(i-1) == str2.charAt(j-1)) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        \n        // Reconstruct LCS string\n        StringBuilder lcs = new StringBuilder();\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (str1.charAt(i-1) == str2.charAt(j-1)) {\n                lcs.append(str1.charAt(i-1));\n                i--;\n                j--;\n            } else if (dp[i-1][j] > dp[i][j-1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        return lcs.reverse().toString();\n    }\n    \n    // Space optimized version\n    public static int lcsOptimized(String str1, String str2) {\n        if (str1.length() < str2.length()) {\n            String temp = str1;\n            str1 = str2;\n            str2 = temp;\n        }\n        \n        int m = str1.length(), n = str2.length();\n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (str1.charAt(i-1) == str2.charAt(j-1)) {\n                    curr[j] = prev[j-1] + 1;\n                } else {\n                    curr[j] = Math.max(prev[j], curr[j-1]);\n                }\n            }\n            int[] temp = prev;\n            prev = curr;\n            curr = temp;\n        }\n        \n        return prev[n];\n    }\n}",
    "cpp": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint lcs_length(const string& str1, const string& str2) {\n    int m = str1.length(), n = str2.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (str1[i-1] == str2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\nstring lcs_string(const string& str1, const string& str2) {\n    int m = str1.length(), n = str2.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    // Build DP table\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (str1[i-1] == str2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    // Reconstruct LCS string\n    string lcs;\n    int i = m, j = n;\n    while (i > 0 && j > 0) {\n        if (str1[i-1] == str2[j-1]) {\n            lcs.push_back(str1[i-1]);\n            i--;\n            j--;\n        } else if (dp[i-1][j] > dp[i][j-1]) {\n            i--;\n        } else {\n            j--;\n        }\n    }\n    \n    reverse(lcs.begin(), lcs.end());\n    return lcs;\n}\n\n// Space optimized version\nint lcs_optimized(const string& str1, const string& str2) {\n    string s1 = str1, s2 = str2;\n    if (s1.length() < s2.length()) {\n        swap(s1, s2); // Ensure s2 is shorter\n    }\n    \n    int m = s1.length(), n = s2.length();\n    vector<int> prev(n + 1, 0);\n    vector<int> curr(n + 1, 0);\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i-1] == s2[j-1]) {\n                curr[j] = prev[j-1] + 1;\n            } else {\n                curr[j] = max(prev[j], curr[j-1]);\n            }\n        }\n        swap(prev, curr);\n    }\n    \n    return prev[n];\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["dynamic-programming", "string", "sequence", "alignment"]
  }
}