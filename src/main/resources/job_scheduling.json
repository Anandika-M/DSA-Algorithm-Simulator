{
  "algorithm": {
    "id": "critical_path_method",
    "name": "Critical Path Method (CPM)",
    "category": "Project Management / Scheduling",
    "description": "An algorithm for scheduling a set of project tasks with dependencies. It calculates the longest path (critical path) through the task network, determining the minimum project duration and identifying tasks that cannot be delayed without affecting the project completion time."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're building a house. Some tasks can happen in parallel (framing and plumbing), while others have strict dependencies (you can't install drywall before framing). The critical path is the sequence of tasks that determines the absolute minimum time to complete the house. If any task on this critical path is delayed, the entire project is delayed. Tasks not on the critical path have some flexibility (float time) - you can delay them a bit without affecting the overall completion date."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "The Critical Path Method (CPM) is a project modeling technique that:\n1. Represents tasks as nodes and dependencies as edges in a DAG\n2. Calculates earliest and latest start/finish times for each task\n3. Identifies the critical path - longest path through the network\n4. Determines float/slack time for non-critical tasks\n\n**Key Idea:** The project completion time is determined by the longest path through the task dependency network. Tasks on this path have zero float and cannot be delayed."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Critical Path Method\"] --> B[\"Create task graph with:\n- Tasks as vertices\n- Dependencies as edges\n- Durations as weights\"]\n    B --> C[\"Add dummy start/end nodes\nwith 0 duration\"]\n    C --> D[\"Forward Pass:\nCalculate earliest times\"]\n    D --> E[\"For each task in topological order\"]\n    E --> F[\"Earliest Start ES = max earliest finish of predecessors\"]\n    F --> G[\"Earliest Finish EF = ES + duration\"]\n    G --> H{\"More tasks?\"}\n    H -->|Yes| E\n    H -->|No| I[\"Backward Pass:\nCalculate latest times\"]\n    I --> J[\"For each task in reverse topological order\"]\n    J --> K[\"Latest Finish LF = min latest start of successors\"]\n    K --> L[\"Latest Start LS = LF - duration\"]\n    L --> M{\"More tasks?\"}\n    M -->|Yes| J\n    M -->|No| N[\"Calculate Float/Slack:\nFloat = LS - ES = LF - EF\"]\n    N --> O[\"Identify Critical Path:\nTasks with zero float\"]\n    O --> P[\"Calculate Project Duration:\nEF of end node\"]\n    P --> Q[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Project Tasks with Durations and Dependencies:**\n\n| Task | Duration | Dependencies |\n|------|----------|--------------|\n| A | 3 | - |\n| B | 4 | - |\n| C | 2 | A |\n| D | 5 | A, B |\n| E | 1 | C, D |\n| F | 3 | B |\n\n**Task Network:**\n```\n    Start\n     / \\\n    A   B\n   / \\ / \\\n  C   D   F\n   \\ /    |\n    E     |\n     \\    /\n      End\n```\n\n**Forward Pass (Earliest Times):**\n- Start: ES=0, EF=0\n- A: ES=0, EF=3\n- B: ES=0, EF=4\n- C: ES=3, EF=5\n- D: ES=max(3,4)=4, EF=9\n- E: ES=max(5,9)=9, EF=10\n- F: ES=4, EF=7\n- End: ES=max(10,7)=10, EF=10\n\n**Backward Pass (Latest Times):**\n- End: LF=10, LS=10\n- E: LF=10, LS=9\n- F: LF=10, LS=7\n- D: LF=9, LS=4\n- C: LF=9, LS=7\n- B: LF=min(4,7)=4, LS=0\n- A: LF=min(3,4)=3, LS=0\n- Start: LF=0, LS=0\n\n**Float Calculation:**\n- A: Float = 0-0 = 0 (Critical)\n- B: Float = 0-0 = 0 (Critical)\n- C: Float = 7-3 = 4\n- D: Float = 4-4 = 0 (Critical)\n- E: Float = 9-9 = 0 (Critical)\n- F: Float = 7-4 = 3\n\n**Critical Path:** Start → B → D → E → End\n**Project Duration:** 10 time units\n\n**Key Insights:**\n- Tasks A, B, D, E are critical (zero float)\n- Task C has 4 units of float, Task F has 3 units\n- Project cannot be completed in less than 10 time units"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(V + E)** - where V is tasks, E is dependencies\n- Requires topological sort + forward/backward passes\n\n### Space Complexity:\n- **O(V + E)** - for storing task graph and time arrays\n\n### Requirements:\n- **Directed Acyclic Graph (DAG)** - no cyclic dependencies\n- **Task durations** must be known\n- **Dependencies** must be clearly defined\n\n### Optimality:\n- **Optimal** for determining minimum project duration\n- **Identifies** critical tasks that control project timeline\n\n### When to Use Critical Path Method:\n\n**✅ Suitable for:**\n- Project management and scheduling\n- Construction project planning\n- Software development timelines\n- Manufacturing process optimization\n- Research project planning\n- Event planning\n\n**❌ Not suitable for:**\n- Projects with uncertain task durations\n- Agile development with changing requirements\n- When dependencies are not well-defined\n- Very large projects with thousands of tasks\n\n### Key Metrics Calculated:\n1. **Earliest Start (ES)** - earliest possible start time\n2. **Earliest Finish (EF)** - ES + duration\n3. **Latest Start (LS)** - latest possible start without delay\n4. **Latest Finish (LF)** - LS + duration\n5. **Float/Slack** - LS - ES = LF - EF\n6. **Critical Path** - tasks with zero float\n\n### Variations:\n1. **PERT** - Program Evaluation and Review Technique (probabilistic durations)\n2. **Gantt Charts** - visual representation of schedule\n3. **Resource Leveling** - considering resource constraints\n4. **Fast Tracking** - overlapping tasks to reduce duration\n\n### Optimization Tips:\n1. **Use topological sort** for efficient forward/backward passes\n2. **Maintain predecessor/successor lists** for quick access\n3. **Handle multiple dependencies** correctly using max/min\n4. **Visualize results** with Gantt charts for better understanding\n\n### Common Applications:\n1. **Construction Management** - building projects\n2. **Software Development** - release planning\n3. **Manufacturing** - production scheduling\n4. **Research Projects** - timeline management\n5. **Event Planning** - conference/wedding scheduling\n6. **Product Development** - new product launches"
    }
  ],
  "code_examples": {
    "python": "from collections import deque, defaultdict\n\nclass CriticalPathMethod:\n    def __init__(self):\n        self.tasks = {}\n        self.dependencies = defaultdict(list)\n        self.reverse_dependencies = defaultdict(list)\n    \n    def add_task(self, task_id, duration, dependencies=None):\n        self.tasks[task_id] = {\n            'duration': duration,\n            'es': 0, 'ef': 0, 'ls': 0, 'lf': 0, 'float': 0\n        }\n        if dependencies:\n            self.dependencies[task_id] = dependencies\n            for dep in dependencies:\n                self.reverse_dependencies[dep].append(task_id)\n    \n    def calculate_critical_path(self):\n        # Add start and end nodes\n        self._add_dummy_nodes()\n        \n        # Topological sort\n        topo_order = self._topological_sort()\n        if not topo_order:\n            return None  # Cycle detected\n        \n        # Forward pass - calculate earliest times\n        self._forward_pass(topo_order)\n        \n        # Backward pass - calculate latest times\n        self._backward_pass(topo_order)\n        \n        # Calculate float and identify critical path\n        critical_path = self._calculate_float_and_critical_path()\n        \n        return critical_path\n    \n    def _add_dummy_nodes(self):\n        \"\"\"Add start and end nodes\"\"\"\n        # Find tasks with no dependencies\n        start_tasks = []\n        for task in self.tasks:\n            if not self.dependencies[task]:\n                start_tasks.append(task)\n        \n        # Add start node\n        self.tasks['START'] = {'duration': 0, 'es': 0, 'ef': 0, 'ls': 0, 'lf': 0, 'float': 0}\n        for task in start_tasks:\n            self.dependencies[task].append('START')\n            self.reverse_dependencies['START'].append(task)\n        \n        # Find tasks with no dependents\n        end_tasks = []\n        for task in self.tasks:\n            if task != 'START' and task not in self.reverse_dependencies:\n                end_tasks.append(task)\n        \n        # Add end node\n        self.tasks['END'] = {'duration': 0, 'es': 0, 'ef': 0, 'ls': 0, 'lf': 0, 'float': 0}\n        for task in end_tasks:\n            self.dependencies['END'].append(task)\n            self.reverse_dependencies[task].append('END')\n    \n    def _topological_sort(self):\n        \"\"\"Kahn's algorithm for topological sort\"\"\"\n        in_degree = defaultdict(int)\n        for u in self.dependencies:\n            for v in self.dependencies[u]:\n                in_degree[v] += 1\n        \n        # Initialize all tasks\n        for task in self.tasks:\n            if task not in in_degree:\n                in_degree[task] = 0\n        \n        queue = deque([task for task in in_degree if in_degree[task] == 0])\n        topo_order = []\n        \n        while queue:\n            u = queue.popleft()\n            topo_order.append(u)\n            \n            for v in self.dependencies.get(u, []):\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n        \n        if len(topo_order) != len(self.tasks):\n            return None  # Cycle\n        \n        return topo_order\n    \n    def _forward_pass(self, topo_order):\n        \"\"\"Calculate earliest start and finish times\"\"\"\n        for task in topo_order:\n            # ES = max(EF of all predecessors)\n            max_ef = 0\n            for pred in self.dependencies.get(task, []):\n                max_ef = max(max_ef, self.tasks[pred]['ef'])\n            \n            self.tasks[task]['es'] = max_ef\n            self.tasks[task]['ef'] = max_ef + self.tasks[task]['duration']\n    \n    def _backward_pass(self, topo_order):\n        \"\"\"Calculate latest start and finish times\"\"\"\n        # Initialize END node\n        self.tasks['END']['lf'] = self.tasks['END']['ef']\n        self.tasks['END']['ls'] = self.tasks['END']['lf']\n        \n        # Process in reverse order\n        for task in reversed(topo_order):\n            if task == 'END':\n                continue\n            \n            # LF = min(LS of all successors)\n            min_ls = float('inf')\n            for succ in self.reverse_dependencies.get(task, []):\n                min_ls = min(min_ls, self.tasks[succ]['ls'])\n            \n            # If no successors, use project completion time\n            if min_ls == float('inf'):\n                min_ls = self.tasks['END']['lf']\n            \n            self.tasks[task]['lf'] = min_ls\n            self.tasks[task]['ls'] = min_ls - self.tasks[task]['duration']\n    \n    def _calculate_float_and_critical_path(self):\n        \"\"\"Calculate float and identify critical path\"\"\"\n        critical_path = []\n        \n        for task in self.tasks:\n            if task not in ['START', 'END']:\n                self.tasks[task]['float'] = self.tasks[task]['ls'] - self.tasks[task]['es']\n                if self.tasks[task]['float'] == 0:\n                    critical_path.append(task)\n        \n        # Reconstruct critical path in order\n        ordered_critical_path = ['START']\n        current = 'START'\n        \n        while current != 'END':\n            # Find critical successor\n            for succ in self.reverse_dependencies.get(current, []):\n                if self.tasks[succ]['float'] == 0:\n                    ordered_critical_path.append(succ)\n                    current = succ\n                    break\n            else:\n                break\n        \n        return ordered_critical_path\n    \n    def print_schedule(self):\n        \"\"\"Print the complete schedule\"\"\"\n        print(f\"{'Task':<10} {'Duration':<10} {'ES':<6} {'EF':<6} {'LS':<6} {'LF':<6} {'Float':<8} {'Critical':<10}\")\n        print(\"-\" * 70)\n        \n        for task in sorted(self.tasks.keys()):\n            if task not in ['START', 'END']:\n                data = self.tasks[task]\n                critical = 'Yes' if data['float'] == 0 else 'No'\n                print(f\"{task:<10} {data['duration']:<10} {data['es']:<6} {data['ef']:<6} \"\n                      f\"{data['ls']:<6} {data['lf']:<6} {data['float']:<8} {critical:<10}\")\n        \n        print(f\"\\nProject Duration: {self.tasks['END']['ef']}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    cpm = CriticalPathMethod()\n    \n    # Add tasks: task_id, duration, dependencies\n    cpm.add_task('A', 3, [])\n    cpm.add_task('B', 4, [])\n    cpm.add_task('C', 2, ['A'])\n    cpm.add_task('D', 5, ['A', 'B'])\n    cpm.add_task('E', 1, ['C', 'D'])\n    cpm.add_task('F', 3, ['B'])\n    \n    critical_path = cpm.calculate_critical_path()\n    \n    if critical_path:\n        print(\"Critical Path:\", \" → \".join(critical_path))\n        cpm.print_schedule()\n    else:\n        print(\"Cycle detected in task dependencies\")",
    "javascript": "class CriticalPathMethod {\n    constructor() {\n        this.tasks = new Map();\n        this.dependencies = new Map();\n        this.reverseDependencies = new Map();\n    }\n    \n    addTask(taskId, duration, dependencies = []) {\n        this.tasks.set(taskId, {\n            duration,\n            es: 0, ef: 0, ls: 0, lf: 0, float: 0\n        });\n        \n        this.dependencies.set(taskId, dependencies);\n        \n        for (const dep of dependencies) {\n            if (!this.reverseDependencies.has(dep)) {\n                this.reverseDependencies.set(dep, []);\n            }\n            this.reverseDependencies.get(dep).push(taskId);\n        }\n    }\n    \n    calculateCriticalPath() {\n        this._addDummyNodes();\n        \n        const topoOrder = this._topologicalSort();\n        if (!topoOrder) return null;\n        \n        this._forwardPass(topoOrder);\n        this._backwardPass(topoOrder);\n        \n        return this._calculateFloatAndCriticalPath();\n    }\n    \n    _addDummyNodes() {\n        // Add START node\n        const startTasks = [];\n        for (const [taskId] of this.tasks) {\n            const deps = this.dependencies.get(taskId) || [];\n            if (deps.length === 0) {\n                startTasks.push(taskId);\n            }\n        }\n        \n        this.tasks.set('START', { duration: 0, es: 0, ef: 0, ls: 0, lf: 0, float: 0 });\n        for (const task of startTasks) {\n            const deps = this.dependencies.get(task) || [];\n            deps.push('START');\n            this.dependencies.set(task, deps);\n            \n            if (!this.reverseDependencies.has('START')) {\n                this.reverseDependencies.set('START', []);\n            }\n            this.reverseDependencies.get('START').push(task);\n        }\n        \n        // Add END node\n        const endTasks = [];\n        for (const [taskId] of this.tasks) {\n            if (taskId !== 'START' && !this.reverseDependencies.has(taskId)) {\n                endTasks.push(taskId);\n            }\n        }\n        \n        this.tasks.set('END', { duration: 0, es: 0, ef: 0, ls: 0, lf: 0, float: 0 });\n        for (const task of endTasks) {\n            if (!this.dependencies.has('END')) {\n                this.dependencies.set('END', []);\n            }\n            this.dependencies.get('END').push(task);\n            \n            if (!this.reverseDependencies.has(task)) {\n                this.reverseDependencies.set(task, []);\n            }\n            this.reverseDependencies.get(task).push('END');\n        }\n    }\n    \n    _topologicalSort() {\n        const inDegree = new Map();\n        \n        // Initialize in-degree\n        for (const [taskId] of this.tasks) {\n            inDegree.set(taskId, 0);\n        }\n        \n        // Calculate in-degree\n        for (const [u, dependencies] of this.dependencies) {\n            for (const v of dependencies) {\n                inDegree.set(v, (inDegree.get(v) || 0) + 1);\n            }\n        }\n        \n        const queue = [];\n        for (const [taskId, degree] of inDegree) {\n            if (degree === 0) {\n                queue.push(taskId);\n            }\n        }\n        \n        const topoOrder = [];\n        while (queue.length > 0) {\n            const u = queue.shift();\n            topoOrder.push(u);\n            \n            for (const v of this.dependencies.get(u) || []) {\n                inDegree.set(v, inDegree.get(v) - 1);\n                if (inDegree.get(v) === 0) {\n                    queue.push(v);\n                }\n            }\n        }\n        \n        return topoOrder.length === this.tasks.size ? topoOrder : null;\n    }\n    \n    _forwardPass(topoOrder) {\n        for (const task of topoOrder) {\n            const taskData = this.tasks.get(task);\n            let maxEf = 0;\n            \n            for (const pred of this.dependencies.get(task) || []) {\n                maxEf = Math.max(maxEf, this.tasks.get(pred).ef);\n            }\n            \n            taskData.es = maxEf;\n            taskData.ef = maxEf + taskData.duration;\n        }\n    }\n    \n    _backwardPass(topoOrder) {\n        // Initialize END node\n        const endData = this.tasks.get('END');\n        endData.lf = endData.ef;\n        endData.ls = endData.lf;\n        \n        for (let i = topoOrder.length - 1; i >= 0; i--) {\n            const task = topoOrder[i];\n            if (task === 'END') continue;\n            \n            const taskData = this.tasks.get(task);\n            let minLs = Infinity;\n            \n            for (const succ of this.reverseDependencies.get(task) || []) {\n                minLs = Math.min(minLs, this.tasks.get(succ).ls);\n            }\n            \n            if (minLs === Infinity) {\n                minLs = endData.lf;\n            }\n            \n            taskData.lf = minLs;\n            taskData.ls = minLs - taskData.duration;\n        }\n    }\n    \n    _calculateFloatAndCriticalPath() {\n        const criticalPath = [];\n        \n        for (const [taskId, taskData] of this.tasks) {\n            if (taskId !== 'START' && taskId !== 'END') {\n                taskData.float = taskData.ls - taskData.es;\n                if (taskData.float === 0) {\n                    criticalPath.push(taskId);\n                }\n            }\n        }\n        \n        // Reconstruct critical path in order\n        const orderedCriticalPath = ['START'];\n        let current = 'START';\n        \n        while (current !== 'END') {\n            const successors = this.reverseDependencies.get(current) || [];\n            let found = false;\n            \n            for (const succ of successors) {\n                if (this.tasks.get(succ).float === 0) {\n                    orderedCriticalPath.push(succ);\n                    current = succ;\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) break;\n        }\n        \n        return orderedCriticalPath;\n    }\n    \n    printSchedule() {\n        console.log('Task      Duration  ES     EF     LS     LF     Float    Critical');\n        console.log('-'.repeat(70));\n        \n        for (const [taskId, taskData] of this.tasks) {\n            if (taskId !== 'START' && taskId !== 'END') {\n                const critical = taskData.float === 0 ? 'Yes' : 'No';\n                console.log(`${taskId.padEnd(9)} ${taskData.duration.toString().padEnd(9)} ` +\n                          `${taskData.es.toString().padEnd(6)} ${taskData.ef.toString().padEnd(6)} ` +\n                          `${taskData.ls.toString().padEnd(6)} ${taskData.lf.toString().padEnd(6)} ` +\n                          `${taskData.float.toString().padEnd(8)} ${critical.padEnd(9)}`);\n            }\n        }\n        \n        console.log(`\\nProject Duration: ${this.tasks.get('END').ef}`);\n    }\n}\n\n// Example usage\nconst cpm = new CriticalPathMethod();\n\ncpm.addTask('A', 3, []);\ncpm.addTask('B', 4, []);\ncpm.addTask('C', 2, ['A']);\ncpm.addTask('D', 5, ['A', 'B']);\ncpm.addTask('E', 1, ['C', 'D']);\ncpm.addTask('F', 3, ['B']);\n\nconst criticalPath = cpm.calculateCriticalPath();\n\nif (criticalPath) {\n    console.log('Critical Path:', criticalPath.join(' → '));\n    cpm.printSchedule();\n} else {\n    console.log('Cycle detected in task dependencies');\n}",
    "java": "import java.util.*;\n\npublic class CriticalPathMethod {\n    static class Task {\n        String id;\n        int duration;\n        int es, ef, ls, lf, floatTime;\n        List<String> dependencies;\n        \n        Task(String id, int duration, List<String> dependencies) {\n            this.id = id;\n            this.duration = duration;\n            this.dependencies = dependencies != null ? dependencies : new ArrayList<>();\n            this.es = this.ef = this.ls = this.lf = this.floatTime = 0;\n        }\n    }\n    \n    private Map<String, Task> tasks = new HashMap<>();\n    private Map<String, List<String>> dependencies = new HashMap<>();\n    private Map<String, List<String>> reverseDependencies = new HashMap<>();\n    \n    public void addTask(String taskId, int duration, List<String> dependencies) {\n        Task task = new Task(taskId, duration, dependencies);\n        tasks.put(taskId, task);\n        this.dependencies.put(taskId, dependencies);\n        \n        for (String dep : dependencies) {\n            reverseDependencies.computeIfAbsent(dep, k -> new ArrayList<>()).add(taskId);\n        }\n    }\n    \n    public List<String> calculateCriticalPath() {\n        addDummyNodes();\n        \n        List<String> topoOrder = topologicalSort();\n        if (topoOrder == null) return null;\n        \n        forwardPass(topoOrder);\n        backwardPass(topoOrder);\n        \n        return calculateFloatAndCriticalPath();\n    }\n    \n    private void addDummyNodes() {\n        // Add START node\n        List<String> startTasks = new ArrayList<>();\n        for (String taskId : tasks.keySet()) {\n            List<String> deps = dependencies.get(taskId);\n            if (deps == null || deps.isEmpty()) {\n                startTasks.add(taskId);\n            }\n        }\n        \n        tasks.put(\"START\", new Task(\"START\", 0, null));\n        for (String task : startTasks) {\n            dependencies.get(task).add(\"START\");\n            reverseDependencies.computeIfAbsent(\"START\", k -> new ArrayList<>()).add(task);\n        }\n        \n        // Add END node\n        List<String> endTasks = new ArrayList<>();\n        for (String taskId : tasks.keySet()) {\n            if (!taskId.equals(\"START\") && !reverseDependencies.containsKey(taskId)) {\n                endTasks.add(taskId);\n            }\n        }\n        \n        tasks.put(\"END\", new Task(\"END\", 0, endTasks));\n        for (String task : endTasks) {\n            reverseDependencies.computeIfAbsent(task, k -> new ArrayList<>()).add(\"END\");\n        }\n    }\n    \n    private List<String> topologicalSort() {\n        Map<String, Integer> inDegree = new HashMap<>();\n        \n        // Initialize in-degree\n        for (String taskId : tasks.keySet()) {\n            inDegree.put(taskId, 0);\n        }\n        \n        // Calculate in-degree\n        for (List<String> deps : dependencies.values()) {\n            for (String dep : deps) {\n                inDegree.put(dep, inDegree.get(dep) + 1);\n            }\n        }\n        \n        Queue<String> queue = new LinkedList<>();\n        for (Map.Entry<String, Integer> entry : inDegree.entrySet()) {\n            if (entry.getValue() == 0) {\n                queue.offer(entry.getKey());\n            }\n        }\n        \n        List<String> topoOrder = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            String u = queue.poll();\n            topoOrder.add(u);\n            \n            for (String v : dependencies.getOrDefault(u, new ArrayList<>())) {\n                inDegree.put(v, inDegree.get(v) - 1);\n                if (inDegree.get(v) == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        \n        return topoOrder.size() == tasks.size() ? topoOrder : null;\n    }\n    \n    private void forwardPass(List<String> topoOrder) {\n        for (String taskId : topoOrder) {\n            Task task = tasks.get(taskId);\n            int maxEf = 0;\n            \n            for (String pred : dependencies.getOrDefault(taskId, new ArrayList<>())) {\n                maxEf = Math.max(maxEf, tasks.get(pred).ef);\n            }\n            \n            task.es = maxEf;\n            task.ef = maxEf + task.duration;\n        }\n    }\n    \n    private void backwardPass(List<String> topoOrder) {\n        // Initialize END node\n        Task end = tasks.get(\"END\");\n        end.lf = end.ef;\n        end.ls = end.lf;\n        \n        for (int i = topoOrder.size() - 1; i >= 0; i--) {\n            String taskId = topoOrder.get(i);\n            if (taskId.equals(\"END\")) continue;\n            \n            Task task = tasks.get(taskId);\n            int minLs = Integer.MAX_VALUE;\n            \n            for (String succ : reverseDependencies.getOrDefault(taskId, new ArrayList<>())) {\n                minLs = Math.min(minLs, tasks.get(succ).ls);\n            }\n            \n            if (minLs == Integer.MAX_VALUE) {\n                minLs = end.lf;\n            }\n            \n            task.lf = minLs;\n            task.ls = minLs - task.duration;\n        }\n    }\n    \n    private List<String> calculateFloatAndCriticalPath() {\n        List<String> criticalPath = new ArrayList<>();\n        \n        for (Task task : tasks.values()) {\n            if (!task.id.equals(\"START\") && !task.id.equals(\"END\")) {\n                task.floatTime = task.ls - task.es;\n                if (task.floatTime == 0) {\n                    criticalPath.add(task.id);\n                }\n            }\n        }\n        \n        // Reconstruct critical path in order\n        List<String> orderedCriticalPath = new ArrayList<>();\n        orderedCriticalPath.add(\"START\");\n        String current = \"START\";\n        \n        while (!current.equals(\"END\")) {\n            List<String> successors = reverseDependencies.getOrDefault(current, new ArrayList<>());\n            boolean found = false;\n            \n            for (String succ : successors) {\n                if (tasks.get(succ).floatTime == 0) {\n                    orderedCriticalPath.add(succ);\n                    current = succ;\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) break;\n        }\n        \n        return orderedCriticalPath;\n    }\n    \n    public void printSchedule() {\n        System.out.printf(\"%-10s %-10s %-6s %-6s %-6s %-6s %-8s %-10s%n\", \n            \"Task\", \"Duration\", \"ES\", \"EF\", \"LS\", \"LF\", \"Float\", \"Critical\");\n        System.out.println(\"-\".repeat(70));\n        \n        for (Task task : tasks.values()) {\n            if (!task.id.equals(\"START\") && !task.id.equals(\"END\")) {\n                String critical = task.floatTime == 0 ? \"Yes\" : \"No\";\n                System.out.printf(\"%-10s %-10d %-6d %-6d %-6d %-6d %-8d %-10s%n\",\n                    task.id, task.duration, task.es, task.ef, task.ls, task.lf, task.floatTime, critical);\n            }\n        }\n        \n        System.out.println(\"\\nProject Duration: \" + tasks.get(\"END\").ef);\n    }\n    \n    public static void main(String[] args) {\n        CriticalPathMethod cpm = new CriticalPathMethod();\n        \n        cpm.addTask(\"A\", 3, new ArrayList<>());\n        cpm.addTask(\"B\", 4, new ArrayList<>());\n        cpm.addTask(\"C\", 2, Arrays.asList(\"A\"));\n        cpm.addTask(\"D\", 5, Arrays.asList(\"A\", \"B\"));\n        cpm.addTask(\"E\", 1, Arrays.asList(\"C\", \"D\"));\n        cpm.addTask(\"F\", 3, Arrays.asList(\"B\"));\n        \n        List<String> criticalPath = cpm.calculateCriticalPath();\n        \n        if (criticalPath != null) {\n            System.out.println(\"Critical Path: \" + String.join(\" → \", criticalPath));\n            cpm.printSchedule();\n        } else {\n            System.out.println(\"Cycle detected in task dependencies\");\n        }\n    }\n}"
  },
  "metadata": {
    "difficulty": "Advanced",
    "last_updated": "2024-01-15",
    "tags": ["project-management", "scheduling", "critical-path", "dag", "optimization"]
  }
}