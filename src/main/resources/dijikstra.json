{
  "algorithm": {
    "id": "dijkstra_algorithm",
    "name": "Dijkstra's Algorithm",
    "category": "Graph Algorithms",
    "description": "A greedy algorithm that finds the shortest paths from a source node to all other nodes in a graph with non-negative edge weights. Uses a priority queue to efficiently select the next closest node."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're planning the fastest driving route from your home to various destinations in a city. You start by knowing the travel time to your immediate neighbors. Then you explore the quickest route to the next closest location, updating your knowledge of travel times as you discover shorter paths. You systematically expand your knowledge outward, always checking the closest reachable location next, until you know the fastest route to every destination."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Dijkstra's algorithm solves the single-source shortest path problem for a graph with non-negative edge weights. It maintains a set of visited nodes and a priority queue of unvisited nodes, always processing the node with the smallest known distance next.\n\n**Key Idea:** Greedy approach - at each step, visit the unvisited node with the smallest known distance from the source. Update distances to its neighbors if a shorter path is found through this node."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Dijkstra\"] --> B[\"Initialize:\n- distsource = 0\n- distothers = ∞\n- Priority queue with source\"]\n    B --> C{\"Priority queue empty?\"}\n    C -->|No| D[\"Extract min node u from queue\"]\n    D --> E[\"Mark u as visited\"]\n    E --> F[\"For each neighbor v of u\"]\n    F --> G{\"v not visited AND\ndistu + weightu,v < distv?\"]\n    G -->|Yes| H[\"Update distv = distu + weightu,v\nSet parentv = u\nAdd v to queue\"]\n    G -->|No| I[\"Skip this neighbor\"]\n    H --> J{\"More neighbors?\"}\n    I --> J\n    J -->|Yes| F\n    J -->|No| C\n    C -->|Yes| K[\"Return distance array and parent pointers\"]\n    K --> L[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Graph:**\n```\n        (A)\n       / | \\\n      2  4  1\n     /   |   \\\n   (B)   |   (C)\n    |    3    |\n    1    |    2\n    |    |    |\n   (D)---5---(E)\n```\n\n**Shortest paths from A:**\n\n| Step | Current Node | Distance Updates | Priority Queue (node: dist) |\n|------|--------------|------------------|-----------------------------|\n| 0 | - | A:0, others:∞ | [A:0] |\n| 1 | A | B:2, C:1, D:4 | [C:1, B:2, D:4] |\n| 2 | C | E:1+2=3 | [B:2, E:3, D:4] |\n| 3 | B | D:min(4, 2+1)=3 | [D:3, E:3] |\n| 4 | D | E:min(3, 3+5)=3 | [E:3] |\n| 5 | E | - | [] |\n\n**Final Shortest Distances from A:**\n- A: 0\n- B: 2\n- C: 1\n- D: 3\n- E: 3\n\n**Shortest Paths:**\n- A→B: A-B (distance 2)\n- A→C: A-C (distance 1)\n- A→D: A-B-D (distance 3)\n- A→E: A-C-E (distance 3)"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **With Array:** O(V²) - where V is number of vertices\n- **With Binary Heap:** O((V+E) log V)\n- **With Fibonacci Heap:** O(E + V log V)\n\n### Space Complexity:\n- **O(V)** - for distance array and priority queue\n\n### Requirements:\n- **Non-negative edge weights** - critical requirement\n- **Connected graph** (or finds shortest paths to reachable nodes)\n\n### Optimality:\n- **Yes** - always finds shortest path with non-negative weights\n\n### When to Use Dijkstra's Algorithm:\n\n**✅ Suitable for:**\n- GPS navigation systems\n- Network routing protocols\n- Social network analysis (degrees of separation)\n- Game pathfinding (with non-negative weights)\n- Transportation networks\n- Any shortest path problem with non-negative weights\n\n**❌ Not suitable for:**\n- Graphs with negative edge weights\n- Very large sparse graphs (consider A* with good heuristic)\n- When only single destination is needed (consider bidirectional)\n\n### Variations:\n1. **Bidirectional Dijkstra** - search from both start and end\n2. **A* Algorithm** - Dijkstra with heuristic for guidance\n3. **Yen's Algorithm** - k shortest paths\n4. **Dial's Algorithm** - for small integer weights\n\n### Optimization Tips:\n1. **Use proper priority queue** (binary heap for general cases)\n2. **Stop early** if only need path to specific destination\n3. **Use bidirectional search** for single destination\n4. **Preprocess graphs** for repeated queries\n5. **Use A*** when good heuristic is available\n\n### Common Applications:\n1. **GPS Navigation** - finding fastest routes\n2. **Network Routing** - OSPF, IS-IS protocols\n3. **Social Networks** - finding closest connections\n4. **Robotics** - path planning\n5. **Circuit Design** - wire routing\n6. **Flight Planning** - optimal air routes"
    }
  ],
  "code_examples": {
    "python": "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    \"\"\"\n    graph: dict of dict - {node: {neighbor: weight}}\n    start: starting node\n    returns: distances from start to all nodes\n    \"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue: (distance, node)\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        # Skip if we found a better path already\n        if current_dist > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = current_dist + weight\n            \n            # If found shorter path to neighbor\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef dijkstra_with_path(graph, start, end):\n    \"\"\"Returns shortest path and distance from start to end\"\"\"\n    distances = {node: float('inf') for node in graph}\n    predecessors = {node: None for node in graph}\n    distances[start] = 0\n    \n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current_node = heapq.heappop(pq)\n        \n        # Early stop if reached destination\n        if current_node == end:\n            break\n        \n        if current_dist > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                predecessors[neighbor] = current_node\n                heapq.heappush(pq, (distance, neighbor))\n    \n    # Reconstruct path\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = predecessors[current]\n    path.reverse()\n    \n    return distances[end], path\n\n# Example usage\ngraph = {\n    'A': {'B': 2, 'C': 1, 'D': 4},\n    'B': {'A': 2, 'D': 1},\n    'C': {'A': 1, 'E': 2},\n    'D': {'A': 4, 'B': 1, 'E': 5},\n    'E': {'C': 2, 'D': 5}\n}\n\nprint(\"Distances from A:\", dijkstra(graph, 'A'))\ndist, path = dijkstra_with_path(graph, 'A', 'E')\nprint(f\"Shortest path A->E: {path} (distance: {dist})\")",
    "javascript": "function dijkstra(graph, start) {\n    const distances = {};\n    const pq = new MinPriorityQueue();\n    \n    // Initialize distances\n    for (const node in graph) {\n        distances[node] = Infinity;\n    }\n    distances[start] = 0;\n    pq.enqueue(start, 0);\n    \n    while (!pq.isEmpty()) {\n        const { element: current, priority: currentDist } = pq.dequeue();\n        \n        // Skip if we found a better path already\n        if (currentDist > distances[current]) continue;\n        \n        for (const [neighbor, weight] of Object.entries(graph[current])) {\n            const distance = currentDist + weight;\n            \n            if (distance < distances[neighbor]) {\n                distances[neighbor] = distance;\n                pq.enqueue(neighbor, distance);\n            }\n        }\n    }\n    \n    return distances;\n}\n\n// Simple MinPriorityQueue implementation\nclass MinPriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n    \n    enqueue(element, priority) {\n        this.heap.push({ element, priority });\n        this.bubbleUp();\n    }\n    \n    dequeue() {\n        const min = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this.sinkDown();\n        }\n        return min;\n    }\n    \n    isEmpty() {\n        return this.heap.length === 0;\n    }\n    \n    bubbleUp() {\n        let idx = this.heap.length - 1;\n        const element = this.heap[idx];\n        while (idx > 0) {\n            let parentIdx = Math.floor((idx - 1) / 2);\n            let parent = this.heap[parentIdx];\n            if (element.priority >= parent.priority) break;\n            this.heap[parentIdx] = element;\n            this.heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n    \n    sinkDown() {\n        let idx = 0;\n        const length = this.heap.length;\n        const element = this.heap[0];\n        \n        while (true) {\n            let leftChildIdx = 2 * idx + 1;\n            let rightChildIdx = 2 * idx + 2;\n            let leftChild, rightChild;\n            let swap = null;\n            \n            if (leftChildIdx < length) {\n                leftChild = this.heap[leftChildIdx];\n                if (leftChild.priority < element.priority) {\n                    swap = leftChildIdx;\n                }\n            }\n            \n            if (rightChildIdx < length) {\n                rightChild = this.heap[rightChildIdx];\n                if ((swap === null && rightChild.priority < element.priority) ||\n                    (swap !== null && rightChild.priority < leftChild.priority)) {\n                    swap = rightChildIdx;\n                }\n            }\n            \n            if (swap === null) break;\n            this.heap[idx] = this.heap[swap];\n            this.heap[swap] = element;\n            idx = swap;\n        }\n    }\n}\n\n// Example usage\nconst graph = {\n    'A': { 'B': 2, 'C': 1, 'D': 4 },\n    'B': { 'A': 2, 'D': 1 },\n    'C': { 'A': 1, 'E': 2 },\n    'D': { 'A': 4, 'B': 1, 'E': 5 },\n    'E': { 'C': 2, 'D': 5 }\n};\n\nconsole.log(\"Distances from A:\", dijkstra(graph, 'A'));",
    "java": "import java.util.*;\n\npublic class Dijkstra {\n    public static Map<String, Integer> dijkstra(Map<String, Map<String, Integer>> graph, String start) {\n        Map<String, Integer> distances = new HashMap<>();\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(n -> n.distance));\n        \n        // Initialize distances\n        for (String node : graph.keySet()) {\n            distances.put(node, Integer.MAX_VALUE);\n        }\n        distances.put(start, 0);\n        pq.offer(new Node(start, 0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            \n            // Skip if we found a better path already\n            if (current.distance > distances.get(current.name)) continue;\n            \n            for (Map.Entry<String, Integer> neighbor : graph.get(current.name).entrySet()) {\n                String neighborName = neighbor.getKey();\n                int weight = neighbor.getValue();\n                int distance = current.distance + weight;\n                \n                if (distance < distances.get(neighborName)) {\n                    distances.put(neighborName, distance);\n                    pq.offer(new Node(neighborName, distance));\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    static class Node {\n        String name;\n        int distance;\n        \n        Node(String name, int distance) {\n            this.name = name;\n            this.distance = distance;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Map<String, Map<String, Integer>> graph = new HashMap<>();\n        graph.put(\"A\", Map.of(\"B\", 2, \"C\", 1, \"D\", 4));\n        graph.put(\"B\", Map.of(\"A\", 2, \"D\", 1));\n        graph.put(\"C\", Map.of(\"A\", 1, \"E\", 2));\n        graph.put(\"D\", Map.of(\"A\", 4, \"B\", 1, \"E\", 5));\n        graph.put(\"E\", Map.of(\"C\", 2, \"D\", 5));\n        \n        System.out.println(\"Distances from A: \" + dijkstra(graph, \"A\"));\n    }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <limits>\nusing namespace std;\n\nvector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, numeric_limits<int>::max());\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int current_node = pq.top().second;\n        pq.pop();\n        \n        // Skip if we found a better path already\n        if (current_dist > dist[current_node]) continue;\n        \n        for (auto& neighbor : graph[current_node]) {\n            int next_node = neighbor.first;\n            int weight = neighbor.second;\n            int distance = current_dist + weight;\n            \n            if (distance < dist[next_node]) {\n                dist[next_node] = distance;\n                pq.push({distance, next_node});\n            }\n        }\n    }\n    \n    return dist;\n}\n\n// Example usage\nint main() {\n    // Graph: 5 nodes (0=A, 1=B, 2=C, 3=D, 4=E)\n    int n = 5;\n    vector<vector<pair<int, int>>> graph(n);\n    \n    graph[0] = {{1, 2}, {2, 1}, {3, 4}}; // A: B2, C1, D4\n    graph[1] = {{0, 2}, {3, 1}};          // B: A2, D1\n    graph[2] = {{0, 1}, {4, 2}};          // C: A1, E2\n    graph[3] = {{0, 4}, {1, 1}, {4, 5}};  // D: A4, B1, E5\n    graph[4] = {{2, 2}, {3, 5}};          // E: C2, D5\n    \n    vector<int> distances = dijkstra(graph, 0);\n    \n    cout << \"Distances from A:\" << endl;\n    for (int i = 0; i < n; i++) {\n        cout << \"To node \" << i << \": \" << distances[i] << endl;\n    }\n    \n    return 0;\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["graph", "shortest-path", "greedy", "priority-queue", "non-negative-weights"]
  }
}