{
  "algorithm": {
    "id": "prim_algorithm",
    "name": "Prim's Algorithm",
    "category": "Graph Algorithms / Minimum Spanning Tree",
    "description": "A greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It grows the MST one vertex at a time, always adding the cheapest edge that connects a vertex in the MST to a vertex outside the MST."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're building a railway network to connect several cities with minimum total track construction cost. You start by choosing one city as your hub. From this hub, you build the cheapest possible track to connect to the nearest city. Now you have two connected cities. From these two cities, you look for the cheapest track to any unconnected city, and continue this process. You always expand your network by adding the least expensive connection from the already-connected cities to the unconnected ones, until all cities are linked with the minimum total cost."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Prim's algorithm finds the Minimum Spanning Tree (MST) of a connected, undirected graph with weighted edges. Unlike Kruskal's which considers all edges, Prim's grows the MST from an arbitrary starting vertex, always adding the minimum-weight edge that connects the growing MST to a vertex not yet in the MST.\n\n**Key Idea:** Maintain two sets - vertices included in MST and vertices not yet included. At each step, add the vertex that has the minimum edge weight connecting it to the current MST."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Prim's Algorithm\"] --> B[\"Initialize:\n- MST as empty set\n- Key values: all ∞ except start=0\n- Parent array: all -1\n- Priority queue with all vertices\"]\n    B --> C{\"Priority queue empty?\"}\n    C -->|No| D[\"Extract min vertex u from queue\"]\n    D --> E[\"Add u to MST\nusing parent[u], u edge\"]\n    E --> F[\"For each neighbor v of u\"]\n    F --> G{\"v in queue AND\nweightu,v < key[v]?\"}\n    G -->|Yes| H[\"Update key[v] = weightu,v\nUpdate parent[v] = u\nDecrease priority of v in queue\"]\n    G -->|No| I[\"Skip this neighbor\"]\n    H --> J{\"More neighbors?\"}\n    I --> J\n    J -->|Yes| F\n    J -->|No| C\n    C -->|Yes| K[\"Return MST\"]\n    K --> L[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Graph:**\n```\n        (A)\n       / | \\\n      1  3  4\n     /   |   \\\n   (B)   |   (C)\n    |    2    |\n    4    |    5\n    |    |    |\n   (D)---6---(E)\n```\n\n**Prim's MST Construction starting from A:**\n\n| Step | Current MST Vertices | Candidate Edges | Chosen Edge | Key Updates |\n|------|---------------------|-----------------|-------------|-------------|\n| 0 | {A} | - | - | key[A]=0 |\n| 1 | {A} | A-B:1, A-C:3, A-D:4 | A-B:1 | key[B]=1, parent[B]=A |\n| 2 | {A,B} | A-C:3, A-D:4, B-D:4 | A-C:3 | key[C]=3, parent[C]=A |\n| 3 | {A,B,C} | A-D:4, B-D:4, C-E:2 | C-E:2 | key[E]=2, parent[E]=C |\n| 4 | {A,B,C,E} | A-D:4, B-D:4, C-D:5 | B-D:4 | key[D]=4, parent[D]=B |\n\n**MST Complete** (V-1 = 4 edges for 5 vertices)\n\n**Final MST:** A-B (1), A-C (3), C-E (2), B-D (4)\n**Total Weight:** 1 + 3 + 2 + 4 = 10\n\n**MST Visualization:**\n```\n    (A)\n   /   \\\n  1     3\n /       \\\n(B)     (C)\n |       |\n 4       2\n |       |\n(D)     (E)\n```\n\n**Note:** This produces the same MST as Kruskal's but through a different process."
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **With Adjacency Matrix:** O(V²)\n- **With Binary Heap + Adjacency List:** O(E log V)\n- **With Fibonacci Heap + Adjacency List:** O(E + V log V)\n\n### Space Complexity:\n- **O(V + E)** - for storing graph and priority queue\n\n### Requirements:\n- **Undirected graph**\n- **Connected graph** (or finds MST for each connected component)\n- **Weighted edges**\n\n### Optimality:\n- **Yes** - always finds minimum spanning tree\n\n### When to Use Prim's Algorithm:\n\n**✅ Suitable for:**\n- Dense graphs (E ≈ V²)\n- When you have adjacency matrix representation\n- When you need the MST rooted at specific node\n- Real-time applications where graph updates are infrequent\n\n**❌ Not suitable for:**\n- Very large sparse graphs\n- Dynamic graphs where edges change frequently\n- When memory is limited (adjacency matrix can be large)\n\n### Prim's vs Kruskal's:\n\n| Aspect | Prim's Algorithm | Kruskal's Algorithm |\n|--------|------------------|---------------------|\n| **Approach** | Vertex-based growth | Edge-based selection |\n| **Data Structure** | Priority queue | Union-Find + sorted edges |\n| **Best For** | Dense graphs | Sparse graphs |\n| **Memory** | O(V²) with matrix | O(E) with list |\n| **Time Complexity** | O(V²) or O(E log V) | O(E log E) |\n\n### Optimization Tips:\n1. **Use adjacency list** with binary heap for sparse graphs\n2. **Use adjacency matrix** with array for dense graphs\n3. **Stop early** when V-1 edges are selected\n4. **Use Fibonacci heap** for theoretical improvement\n5. **Lazy deletion** in priority queue for simpler implementation\n\n### Common Applications:\n1. **Network Design** - computer networks, transportation\n2. **Cluster Analysis** - finding natural groupings in data\n3. **Image Segmentation** - connecting similar pixels\n4. **Circuit Design** - minimum wire length connections\n5. **Approximation Algorithms** - for NP-hard problems\n6. **Game Development** - procedural terrain generation"
    }
  ],
  "code_examples": {
    "python": "import heapq\n\ndef prim_adjacency_list(graph, start=0):\n    \"\"\"\n    Prim's algorithm using adjacency list and min-heap\n    graph: list of lists of (neighbor, weight)\n    start: starting vertex\n    returns: (parent array, total_weight)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    parent = [-1] * n\n    key = [float('inf')] * n\n    \n    key[start] = 0\n    # Priority queue: (key, vertex)\n    pq = [(0, start)]\n    \n    while pq:\n        current_key, u = heapq.heappop(pq)\n        \n        if visited[u]:\n            continue\n        \n        visited[u] = True\n        \n        for v, weight in graph[u]:\n            if not visited[v] and weight < key[v]:\n                key[v] = weight\n                parent[v] = u\n                heapq.heappush(pq, (weight, v))\n    \n    total_weight = sum(key)\n    return parent, total_weight\n\ndef prim_adjacency_matrix(graph, start=0):\n    \"\"\"\n    Prim's algorithm using adjacency matrix\n    graph: 2D list where graph[i][j] = weight, 0 if no edge\n    start: starting vertex\n    returns: (parent array, total_weight)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    parent = [-1] * n\n    key = [float('inf')] * n\n    \n    key[start] = 0\n    \n    for _ in range(n):\n        # Find vertex with minimum key value\n        u = -1\n        min_key = float('inf')\n        for i in range(n):\n            if not visited[i] and key[i] < min_key:\n                min_key = key[i]\n                u = i\n        \n        if u == -1:\n            break\n        \n        visited[u] = True\n        \n        # Update key values of adjacent vertices\n        for v in range(n):\n            if (graph[u][v] > 0 and not visited[v] and \n                graph[u][v] < key[v]):\n                key[v] = graph[u][v]\n                parent[v] = u\n    \n    total_weight = sum(key)\n    return parent, total_weight\n\ndef get_mst_edges(parent):\n    \"\"\"Convert parent array to MST edges\"\"\"\n    edges = []\n    for i in range(len(parent)):\n        if parent[i] != -1:\n            edges.append((parent[i], i))\n    return edges\n\n# Example usage\nif __name__ == \"__main__\":\n    # Using adjacency list representation\n    # Graph: 5 vertices (0=A, 1=B, 2=C, 3=D, 4=E)\n    graph_list = [\n        [(1, 1), (2, 3), (3, 4)],  # A: B1, C3, D4\n        [(0, 1), (3, 4)],          # B: A1, D4\n        [(0, 3), (4, 2)],          # C: A3, E2\n        [(0, 4), (1, 4)],          # D: A4, B4\n        [(2, 2)]                   # E: C2\n    ]\n    \n    parent, total_weight = prim_adjacency_list(graph_list, 0)\n    mst_edges = get_mst_edges(parent)\n    \n    print(\"Prim's MST (Adjacency List):\")\n    print(f\"Total weight: {total_weight}\")\n    print(\"Edges:\", mst_edges)\n    \n    # Using adjacency matrix representation\n    graph_matrix = [\n        [0, 1, 3, 4, 0],\n        [1, 0, 0, 4, 0],\n        [3, 0, 0, 0, 2],\n        [4, 4, 0, 0, 0],\n        [0, 0, 2, 0, 0]\n    ]\n    \n    parent, total_weight = prim_adjacency_matrix(graph_matrix, 0)\n    mst_edges = get_mst_edges(parent)\n    \n    print(\"\\nPrim's MST (Adjacency Matrix):\")\n    print(f\"Total weight: {total_weight}\")\n    print(\"Edges:\", mst_edges)",
    "javascript": "function primAdjacencyList(graph, start = 0) {\n    const n = graph.length;\n    const visited = new Array(n).fill(false);\n    const parent = new Array(n).fill(-1);\n    const key = new Array(n).fill(Infinity);\n    \n    key[start] = 0;\n    \n    // Priority queue using min-heap\n    const pq = new MinPriorityQueue();\n    pq.enqueue(start, 0);\n    \n    while (!pq.isEmpty()) {\n        const { element: u, priority: currentKey } = pq.dequeue();\n        \n        if (visited[u]) continue;\n        \n        visited[u] = true;\n        \n        for (const [v, weight] of graph[u]) {\n            if (!visited[v] && weight < key[v]) {\n                key[v] = weight;\n                parent[v] = u;\n                pq.enqueue(v, weight);\n            }\n        }\n    }\n    \n    const totalWeight = key.reduce((sum, k) => sum + k, 0);\n    return { parent, totalWeight };\n}\n\nfunction primAdjacencyMatrix(graph, start = 0) {\n    const n = graph.length;\n    const visited = new Array(n).fill(false);\n    const parent = new Array(n).fill(-1);\n    const key = new Array(n).fill(Infinity);\n    \n    key[start] = 0;\n    \n    for (let count = 0; count < n; count++) {\n        // Find vertex with minimum key value\n        let u = -1;\n        let minKey = Infinity;\n        for (let i = 0; i < n; i++) {\n            if (!visited[i] && key[i] < minKey) {\n                minKey = key[i];\n                u = i;\n            }\n        }\n        \n        if (u === -1) break;\n        \n        visited[u] = true;\n        \n        // Update key values of adjacent vertices\n        for (let v = 0; v < n; v++) {\n            if (graph[u][v] > 0 && !visited[v] && graph[u][v] < key[v]) {\n                key[v] = graph[u][v];\n                parent[v] = u;\n            }\n        }\n    }\n    \n    const totalWeight = key.reduce((sum, k) => sum + k, 0);\n    return { parent, totalWeight };\n}\n\nfunction getMstEdges(parent) {\n    const edges = [];\n    for (let i = 0; i < parent.length; i++) {\n        if (parent[i] !== -1) {\n            edges.push([parent[i], i]);\n        }\n    }\n    return edges;\n}\n\n// MinPriorityQueue implementation (same as Dijkstra example)\nclass MinPriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n    \n    enqueue(element, priority) {\n        this.heap.push({ element, priority });\n        this.bubbleUp();\n    }\n    \n    dequeue() {\n        const min = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this.sinkDown();\n        }\n        return min;\n    }\n    \n    isEmpty() {\n        return this.heap.length === 0;\n    }\n    \n    bubbleUp() {\n        let idx = this.heap.length - 1;\n        const element = this.heap[idx];\n        while (idx > 0) {\n            let parentIdx = Math.floor((idx - 1) / 2);\n            let parent = this.heap[parentIdx];\n            if (element.priority >= parent.priority) break;\n            this.heap[parentIdx] = element;\n            this.heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n    \n    sinkDown() {\n        let idx = 0;\n        const length = this.heap.length;\n        const element = this.heap[0];\n        \n        while (true) {\n            let leftChildIdx = 2 * idx + 1;\n            let rightChildIdx = 2 * idx + 2;\n            let leftChild, rightChild;\n            let swap = null;\n            \n            if (leftChildIdx < length) {\n                leftChild = this.heap[leftChildIdx];\n                if (leftChild.priority < element.priority) {\n                    swap = leftChildIdx;\n                }\n            }\n            \n            if (rightChildIdx < length) {\n                rightChild = this.heap[rightChildIdx];\n                if ((swap === null && rightChild.priority < element.priority) ||\n                    (swap !== null && rightChild.priority < leftChild.priority)) {\n                    swap = rightChildIdx;\n                }\n            }\n            \n            if (swap === null) break;\n            this.heap[idx] = this.heap[swap];\n            this.heap[swap] = element;\n            idx = swap;\n        }\n    }\n}\n\n// Example usage\nconst graphList = [\n    [[1, 1], [2, 3], [3, 4]],  // A: B1, C3, D4\n    [[0, 1], [3, 4]],          // B: A1, D4\n    [[0, 3], [4, 2]],          // C: A3, E2\n    [[0, 4], [1, 4]],          // D: A4, B4\n    [[2, 2]]                   // E: C2\n];\n\nconst { parent, totalWeight } = primAdjacencyList(graphList, 0);\nconst mstEdges = getMstEdges(parent);\n\nconsole.log(\"Prim's MST (Adjacency List):\");\nconsole.log(`Total weight: ${totalWeight}`);\nconsole.log(\"Edges:\", mstEdges);",
    "java": "import java.util.*;\n\npublic class Prim {\n    \n    // Prim's with adjacency list and priority queue\n    public static int[] primAdjacencyList(List<List<int[]>> graph, int start) {\n        int n = graph.size();\n        boolean[] visited = new boolean[n];\n        int[] parent = new int[n];\n        int[] key = new int[n];\n        \n        Arrays.fill(parent, -1);\n        Arrays.fill(key, Integer.MAX_VALUE);\n        key[start] = 0;\n        \n        // Priority queue: (key, vertex)\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        pq.offer(new int[]{0, start});\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[1];\n            \n            if (visited[u]) continue;\n            visited[u] = true;\n            \n            for (int[] neighbor : graph.get(u)) {\n                int v = neighbor[0];\n                int weight = neighbor[1];\n                \n                if (!visited[v] && weight < key[v]) {\n                    key[v] = weight;\n                    parent[v] = u;\n                    pq.offer(new int[]{weight, v});\n                }\n            }\n        }\n        \n        return parent;\n    }\n    \n    // Prim's with adjacency matrix\n    public static int[] primAdjacencyMatrix(int[][] graph, int start) {\n        int n = graph.length;\n        boolean[] visited = new boolean[n];\n        int[] parent = new int[n];\n        int[] key = new int[n];\n        \n        Arrays.fill(parent, -1);\n        Arrays.fill(key, Integer.MAX_VALUE);\n        key[start] = 0;\n        \n        for (int count = 0; count < n; count++) {\n            // Find vertex with minimum key value\n            int u = -1;\n            int minKey = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                if (!visited[i] && key[i] < minKey) {\n                    minKey = key[i];\n                    u = i;\n                }\n            }\n            \n            if (u == -1) break;\n            visited[u] = true;\n            \n            // Update key values of adjacent vertices\n            for (int v = 0; v < n; v++) {\n                if (graph[u][v] != 0 && !visited[v] && graph[u][v] < key[v]) {\n                    key[v] = graph[u][v];\n                    parent[v] = u;\n                }\n            }\n        }\n        \n        return parent;\n    }\n    \n    public static int calculateTotalWeight(int[] parent, int[][] graph) {\n        int totalWeight = 0;\n        for (int i = 0; i < parent.length; i++) {\n            if (parent[i] != -1) {\n                totalWeight += graph[parent[i]][i];\n            }\n        }\n        return totalWeight;\n    }\n    \n    public static void printMST(int[] parent) {\n        System.out.println(\"MST Edges:\");\n        for (int i = 0; i < parent.length; i++) {\n            if (parent[i] != -1) {\n                System.out.println(parent[i] + \" - \" + i);\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Using adjacency list\n        int n = 5;\n        List<List<int[]>> graphList = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graphList.add(new ArrayList<>());\n        }\n        \n        // A=0, B=1, C=2, D=3, E=4\n        graphList.get(0).add(new int[]{1, 1}); // A-B:1\n        graphList.get(0).add(new int[]{2, 3}); // A-C:3\n        graphList.get(0).add(new int[]{3, 4}); // A-D:4\n        \n        graphList.get(1).add(new int[]{0, 1}); // B-A:1\n        graphList.get(1).add(new int[]{3, 4}); // B-D:4\n        \n        graphList.get(2).add(new int[]{0, 3}); // C-A:3\n        graphList.get(2).add(new int[]{4, 2}); // C-E:2\n        \n        graphList.get(3).add(new int[]{0, 4}); // D-A:4\n        graphList.get(3).add(new int[]{1, 4}); // D-B:4\n        \n        graphList.get(4).add(new int[]{2, 2}); // E-C:2\n        \n        int[] parent = primAdjacencyList(graphList, 0);\n        System.out.println(\"Prim's MST (Adjacency List):\");\n        printMST(parent);\n        \n        // Using adjacency matrix\n        int[][] graphMatrix = {\n            {0, 1, 3, 4, 0},\n            {1, 0, 0, 4, 0},\n            {3, 0, 0, 0, 2},\n            {4, 4, 0, 0, 0},\n            {0, 0, 2, 0, 0}\n        };\n        \n        parent = primAdjacencyMatrix(graphMatrix, 0);\n        int totalWeight = calculateTotalWeight(parent, graphMatrix);\n        System.out.println(\"\\nPrim's MST (Adjacency Matrix):\");\n        System.out.println(\"Total weight: \" + totalWeight);\n        printMST(parent);\n    }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n// Prim's with adjacency list and priority queue\nvector<int> primAdjacencyList(vector<vector<pair<int, int>>>& graph, int start) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<int> parent(n, -1);\n    vector<int> key(n, INT_MAX);\n    \n    key[start] = 0;\n    \n    // Priority queue: (key, vertex)\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (visited[u]) continue;\n        visited[u] = true;\n        \n        for (auto& neighbor : graph[u]) {\n            int v = neighbor.first;\n            int weight = neighbor.second;\n            \n            if (!visited[v] && weight < key[v]) {\n                key[v] = weight;\n                parent[v] = u;\n                pq.push({weight, v});\n            }\n        }\n    }\n    \n    return parent;\n}\n\n// Prim's with adjacency matrix\nvector<int> primAdjacencyMatrix(vector<vector<int>>& graph, int start) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    vector<int> parent(n, -1);\n    vector<int> key(n, INT_MAX);\n    \n    key[start] = 0;\n    \n    for (int count = 0; count < n; count++) {\n        // Find vertex with minimum key value\n        int u = -1;\n        int minKey = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i] && key[i] < minKey) {\n                minKey = key[i];\n                u = i;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = true;\n        \n        // Update key values of adjacent vertices\n        for (int v = 0; v < n; v++) {\n            if (graph[u][v] != 0 && !visited[v] && graph[u][v] < key[v]) {\n                key[v] = graph[u][v];\n                parent[v] = u;\n            }\n        }\n    }\n    \n    return parent;\n}\n\nint calculateTotalWeight(vector<int>& parent, vector<vector<int>>& graph) {\n    int totalWeight = 0;\n    for (int i = 0; i < parent.size(); i++) {\n        if (parent[i] != -1) {\n            totalWeight += graph[parent[i]][i];\n        }\n    }\n    return totalWeight;\n}\n\nvoid printMST(vector<int>& parent) {\n    cout << \"MST Edges:\" << endl;\n    for (int i = 0; i < parent.size(); i++) {\n        if (parent[i] != -1) {\n            cout << parent[i] << \" - \" << i << endl;\n        }\n    }\n}\n\nint main() {\n    // Using adjacency list\n    int n = 5;\n    vector<vector<pair<int, int>>> graphList(n);\n    \n    // A=0, B=1, C=2, D=3, E=4\n    graphList[0].push_back({1, 1}); // A-B:1\n    graphList[0].push_back({2, 3}); // A-C:3\n    graphList[0].push_back({3, 4}); // A-D:4\n    \n    graphList[1].push_back({0, 1}); // B-A:1\n    graphList[1].push_back({3, 4}); // B-D:4\n    \n    graphList[2].push_back({0, 3}); // C-A:3\n    graphList[2].push_back({4, 2}); // C-E:2\n    \n    graphList[3].push_back({0, 4}); // D-A:4\n    graphList[3].push_back({1, 4}); // D-B:4\n    \n    graphList[4].push_back({2, 2}); // E-C:2\n    \n    vector<int> parent = primAdjacencyList(graphList, 0);\n    cout << \"Prim's MST (Adjacency List):\" << endl;\n    printMST(parent);\n    \n    // Using adjacency matrix\n    vector<vector<int>> graphMatrix = {\n        {0, 1, 3, 4, 0},\n        {1, 0, 0, 4, 0},\n        {3, 0, 0, 0, 2},\n        {4, 4, 0, 0, 0},\n        {0, 0, 2, 0, 0}\n    };\n    \n    parent = primAdjacencyMatrix(graphMatrix, 0);\n    int totalWeight = calculateTotalWeight(parent, graphMatrix);\n    cout << \"\\nPrim's MST (Adjacency Matrix):\" << endl;\n    cout << \"Total weight: \" << totalWeight << endl;\n    printMST(parent);\n    \n    return 0;\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["graph", "minimum-spanning-tree", "greedy", "priority-queue", "mst"]
  }
}