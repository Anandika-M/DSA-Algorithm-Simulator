{
  "algorithm": {
    "id": "fibonacci_sequence",
    "name": "Fibonacci Sequence",
    "category": "Dynamic Programming",
    "description": "A sequence where each number is the sum of the two preceding ones, starting from 0 and 1. Used to demonstrate recursion, dynamic programming, and appears in nature, art, and computer science."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're breeding rabbits. You start with one pair of newborn rabbits. It takes one month for them to mature, and once mature, they produce one new pair of rabbits every month. The new pairs follow the same pattern. The number of rabbit pairs each month follows the Fibonacci sequence: 1, 1, 2, 3, 5, 8, 13... where each month's population is the sum of the previous two months."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "The Fibonacci sequence is defined by the recurrence relation:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n ≥ 2\n\n**Key Idea:** Each number is the sum of the two preceding numbers. This simple recursive definition demonstrates fundamental programming concepts like recursion, memoization, and dynamic programming optimization."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Fibonacci\"] --> B{\"Input n\"}\n    B --> C{\"n ≤ 1?\"}\n    C -->|Yes| D[\"Return n\nBase case: F0=0, F1=1\"]\n    C -->|No| E[\"Recursive case:\nFn = Fn-1 + Fn-2\"]\n    E --> F[\"Compute Fn-1\"]\n    E --> G[\"Compute Fn-2\"]\n    F --> H[\"Sum results: Fn-1 + Fn-2\"]\n    G --> H\n    H --> I[\"Return sum\"]\n    D --> J[\"End\"]\n    I --> J\n\n    style F fill:#e1f5fe\n    style G fill:#e1f5fe\n    style H fill:#e8f5e8\n```"
    },
    {
      "id": "example",
      "label": "Example Calculation",
      "content": "**Fibonacci Sequence first 10 terms:**\n\n| n | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|----|----|----|----|----|----|----|----|----|----|\n| F(n) | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 |\n\n**Calculation for F(5):**\n- F(5) = F(4) + F(3)\n- F(4) = F(3) + F(2) = 2 + 1 = 3\n- F(3) = F(2) + F(1) = 1 + 1 = 2\n- F(2) = F(1) + F(0) = 1 + 0 = 1\n- F(1) = 1, F(0) = 0\n\n**Final:** F(5) = 3 + 2 = 5\n\n**Recursive Tree for F(5):**\n```\n      F(5)\n     /     \\\n   F(4)    F(3)\n  /    \\    /  \\\nF(3)  F(2) F(2) F(1)\n/  \\   / \\  / \\\n... (continues)\n```"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **Naive Recursive:** O(2^n) - exponential growth\n- **Memoized Recursive:** O(n) - linear\n- **Iterative DP:** O(n) - linear\n- **Matrix Exponentiation:** O(log n) - logarithmic\n- **Binet's Formula:** O(1) - constant (but limited by precision)\n\n### Space Complexity:\n- **Naive Recursive:** O(n) - recursion stack\n- **Memoized Recursive:** O(n) - recursion stack + memoization\n- **Iterative DP:** O(1) - constant (with optimization)\n\n### Mathematical Properties:\n- **Golden Ratio:** lim(n→∞) F(n+1)/F(n) = φ ≈ 1.618\n- **Cassini's Identity:** F(n-1)×F(n+1) - F(n)² = (-1)^n\n- **Sum of first n:** F(0)+F(1)+...+F(n) = F(n+2) - 1\n\n### When to Use Different Approaches:\n\n**✅ Naive Recursive:**\n- Educational purposes\n- Small values of n (n < 20)\n- Code simplicity\n\n**✅ Memoized Recursive:**\n- Medium values of n\n- When readability matters\n- Multiple calls with same inputs\n\n**✅ Iterative DP:**\n- Large values of n\n- Memory efficiency\n- Production code\n\n**✅ Matrix Exponentiation:**\n- Very large n (n > 10^6)\n- Competitive programming\n- Mathematical applications\n\n### Optimization Tips:\n1. **Use iterative approach** for production code\n2. **Memoize recursive calls** to avoid repeated calculations\n3. **Use matrix exponentiation** for very large n\n4. **Employ closed-form formula** when precision allows\n5. **Precompute values** for frequently used ranges\n\n### Common Applications:\n1. **Algorithm Analysis** - demonstrating recursion vs DP\n2. **Financial Modeling** - Fibonacci retracements\n3. **Computer Science** - heap construction, Fibonacci heap\n4. **Nature Modeling** - phyllotaxis, spiral patterns\n5. **Cryptography** - Fibonacci-based random number generators\n6. **Game Development** - procedural generation, difficulty scaling"
    }
  ],
  "code_examples": {
    "python": "# Naive recursive (exponential time)\ndef fib_naive(n):\n    if n <= 1:\n        return n\n    return fib_naive(n-1) + fib_naive(n-2)\n\n# Memoized recursive (linear time)\ndef fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n\n# Iterative DP (optimal)\ndef fib_iterative(n):\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Matrix exponentiation (logarithmic time)\ndef fib_matrix(n):\n    if n <= 1:\n        return n\n    \n    def multiply(a, b):\n        return [\n            a[0]*b[0] + a[1]*b[2],\n            a[0]*b[1] + a[1]*b[3],\n            a[2]*b[0] + a[3]*b[2],\n            a[2]*b[1] + a[3]*b[3]\n        ]\n    \n    def power(matrix, n):\n        result = [1, 0, 0, 1]  # Identity matrix\n        while n > 0:\n            if n % 2 == 1:\n                result = multiply(result, matrix)\n            matrix = multiply(matrix, matrix)\n            n //= 2\n        return result\n    \n    base = [1, 1, 1, 0]\n    result = power(base, n - 1)\n    return result[0]\n\n# Example usage\nprint(f\"F(10) naive: {fib_naive(10)}\")      # 55\nprint(f\"F(10) memo: {fib_memo(10)}\")       # 55\nprint(f\"F(10) iterative: {fib_iterative(10)}\") # 55\nprint(f\"F(10) matrix: {fib_matrix(10)}\")   # 55",
    "javascript": "// Naive recursive\nfunction fibNaive(n) {\n    if (n <= 1) return n;\n    return fibNaive(n-1) + fibNaive(n-2);\n}\n\n// Memoized recursive\nfunction fibMemo(n, memo = {}) {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);\n    return memo[n];\n}\n\n// Iterative DP\nfunction fibIterative(n) {\n    if (n <= 1) return n;\n    \n    let a = 0, b = 1;\n    for (let i = 2; i <= n; i++) {\n        [a, b] = [b, a + b];\n    }\n    return b;\n}\n\n// Matrix exponentiation\nfunction fibMatrix(n) {\n    if (n <= 1) return n;\n    \n    function multiply(a, b) {\n        return [\n            a[0]*b[0] + a[1]*b[2],\n            a[0]*b[1] + a[1]*b[3],\n            a[2]*b[0] + a[3]*b[2],\n            a[2]*b[1] + a[3]*b[3]\n        ];\n    }\n    \n    function power(matrix, n) {\n        let result = [1, 0, 0, 1]; // Identity matrix\n        while (n > 0) {\n            if (n % 2 === 1) {\n                result = multiply(result, matrix);\n            }\n            matrix = multiply(matrix, matrix);\n            n = Math.floor(n / 2);\n        }\n        return result;\n    }\n    \n    const base = [1, 1, 1, 0];\n    const result = power(base, n - 1);\n    return result[0];\n}\n\n// Example usage\nconsole.log(`F(10) naive: ${fibNaive(10)}`);      // 55\nconsole.log(`F(10) memo: ${fibMemo(10)}`);       // 55\nconsole.log(`F(10) iterative: ${fibIterative(10)}`); // 55\nconsole.log(`F(10) matrix: ${fibMatrix(10)}`);   // 55",
    "java": "public class Fibonacci {\n    // Naive recursive\n    public static int fibNaive(int n) {\n        if (n <= 1) return n;\n        return fibNaive(n-1) + fibNaive(n-2);\n    }\n    \n    // Memoized recursive\n    public static int fibMemo(int n) {\n        return fibMemoHelper(n, new Integer[n+1]);\n    }\n    \n    private static int fibMemoHelper(int n, Integer[] memo) {\n        if (n <= 1) return n;\n        if (memo[n] != null) return memo[n];\n        memo[n] = fibMemoHelper(n-1, memo) + fibMemoHelper(n-2, memo);\n        return memo[n];\n    }\n    \n    // Iterative DP\n    public static int fibIterative(int n) {\n        if (n <= 1) return n;\n        \n        int a = 0, b = 1;\n        for (int i = 2; i <= n; i++) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n        }\n        return b;\n    }\n    \n    // Matrix exponentiation\n    public static int fibMatrix(int n) {\n        if (n <= 1) return n;\n        \n        int[][] base = {{1, 1}, {1, 0}};\n        int[][] result = power(base, n - 1);\n        return result[0][0];\n    }\n    \n    private static int[][] multiply(int[][] a, int[][] b) {\n        int[][] result = new int[2][2];\n        result[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0];\n        result[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1];\n        result[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0];\n        result[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1];\n        return result;\n    }\n    \n    private static int[][] power(int[][] matrix, int n) {\n        int[][] result = {{1, 0}, {0, 1}}; // Identity matrix\n        while (n > 0) {\n            if (n % 2 == 1) {\n                result = multiply(result, matrix);\n            }\n            matrix = multiply(matrix, matrix);\n            n /= 2;\n        }\n        return result;\n    }\n}",
    "cpp": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Naive recursive\nint fib_naive(int n) {\n    if (n <= 1) return n;\n    return fib_naive(n-1) + fib_naive(n-2);\n}\n\n// Memoized recursive\nint fib_memo(int n, unordered_map<int, int>& memo) {\n    if (memo.count(n)) return memo[n];\n    if (n <= 1) return n;\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo);\n    return memo[n];\n}\n\nint fib_memo(int n) {\n    unordered_map<int, int> memo;\n    return fib_memo(n, memo);\n}\n\n// Iterative DP\nint fib_iterative(int n) {\n    if (n <= 1) return n;\n    \n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n        int temp = b;\n        b = a + b;\n        a = temp;\n    }\n    return b;\n}\n\n// Matrix exponentiation\nint fib_matrix(int n) {\n    if (n <= 1) return n;\n    \n    auto multiply = [](vector<vector<int>> a, vector<vector<int>> b) {\n        vector<vector<int>> result(2, vector<int>(2));\n        result[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0];\n        result[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1];\n        result[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0];\n        result[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1];\n        return result;\n    };\n    \n    auto power = [multiply](vector<vector<int>> matrix, int n) {\n        vector<vector<int>> result = {{1, 0}, {0, 1}}; // Identity\n        while (n > 0) {\n            if (n % 2 == 1) {\n                result = multiply(result, matrix);\n            }\n            matrix = multiply(matrix, matrix);\n            n /= 2;\n        }\n        return result;\n    };\n    \n    vector<vector<int>> base = {{1, 1}, {1, 0}};\n    vector<vector<int>> result = power(base, n - 1);\n    return result[0][0];\n}"
  },
  "metadata": {
    "difficulty": "Beginner",
    "last_updated": "2024-01-15",
    "tags": ["dynamic-programming", "recursion", "mathematics", "sequence"]
  }
}