{
  "algorithm": {
    "id": "coin_change",
    "name": "Coin Change Problem",
    "category": "Dynamic Programming",
    "description": "A classic problem to find the minimum number of coins or number of ways to make a given amount using coins of specified denominations."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're a cashier and need to give a customer change for their purchase. You have a limited set of coin denominations (like pennies, nickels, dimes, quarters). You want to give the customer the exact change using the fewest coins possible. Alternatively, you might want to know all the different combinations of coins that could make up that amount."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "The Coin Change problem has two main variations:\n1. **Minimum Coins**: Find the minimum number of coins needed to make a target amount\n2. **Number of Ways**: Count all possible combinations to make the target amount\n\n**Key Idea:** Use dynamic programming where dp[i] represents the solution for amount i. For each coin, we update all amounts that can be reached by adding that coin."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Coin Change\"] --> B{\"Which variation?\"}\n    B --> C[\"Minimum Coins\"]\n    B --> D[\"Number of Ways\"]\n    \n    C --> E[\"Initialize dp array with infinity\ndp0 = 0\"]\n    E --> F[\"For each coin denomination\"]\n    F --> G[\"For each amount from coin to target\"]\n    G --> H[\"dpamount = min dpamount, 1 + dpamount - coin]\"]\n    H --> I{\"More coins/amounts?\"}\n    I -->|Yes| F\n    I -->|No| J[\"Return dptarget\"]\n    \n    D --> K[\"Initialize dp array with 0\ndp0 = 1\"]\n    K --> L[\"For each coin denomination\"]\n    L --> M[\"For each amount from coin to target\"]\n    M --> N[\"dpamount += dpamount - coin]\"]\n    N --> O{\"More coins/amounts?\"}\n    O -->|Yes| L\n    O -->|No| P[\"Return dptarget\"]\n    \n    J --> Q[\"End\"]\n    P --> Q\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Input:**\n- Coins: [1, 3, 4]\n- Target amount: 6\n\n**Minimum Coins Solution:**\n- dp[0] = 0\n- dp[1] = 1 (coin 1)\n- dp[2] = 2 (1+1)\n- dp[3] = 1 (coin 3)\n- dp[4] = 1 (coin 4)\n- dp[5] = 2 (4+1)\n- dp[6] = 2 (3+3)\n\n**Minimum coins needed: 2** (two coins of 3)\n\n**Number of Ways Solution:**\n- Ways to make 6:\n  - 1+1+1+1+1+1\n  - 1+1+1+3\n  - 1+1+4\n  - 3+3\n  - 4+1+1\n- **Total ways: 5**"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(n×amount)** - where n is number of coin denominations\n\n### Space Complexity:\n- **O(amount)** - for DP array\n\n### Problem Type:\n- **Dynamic Programming**\n- **Combinatorial Optimization**\n\n### When to Use Coin Change Algorithm:\n\n**✅ Suitable for:**\n- Cash register systems\n- Vending machines\n- Financial applications\n- Resource allocation\n- Any combination counting problem\n\n**❌ Not suitable for:**\n- Very large amounts with many denominations\n- Real-time systems with strict timing constraints\n\n### Variations:\n1. **Minimum Coins** - fewest coins to make amount\n2. **Number of Ways** - all combinations to make amount\n3. **Can Make Amount** - boolean decision problem\n4. **Limited Coins** - each coin has limited quantity\n\n### Optimization Tips:\n1. **Sort coins** for early termination\n2. **Use 1D DP array** for space efficiency\n3. **Greedy approach** works for canonical coin systems\n4. **Memoization** for recursive approach\n\n### Common Applications:\n1. **Cash Systems** - vending machines, cash registers\n2. **Financial Planning** - portfolio combinations\n3. **Resource Allocation** - task assignment\n4. **Combinatorics** - counting problems\n5. **Game Development** - scoring systems"
    }
  ],
  "code_examples": {
    "python": "def coin_change_min(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef coin_change_ways(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]\n\n# Example usage\ncoins = [1, 3, 4]\namount = 6\nprint(f\"Minimum coins: {coin_change_min(coins, amount)}\")  # Output: 2\nprint(f\"Number of ways: {coin_change_ways(coins, amount)}\")  # Output: 5",
    "javascript": "function coinChangeMin(coins, amount) {\n    const dp = Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n    \n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n    \n    return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\nfunction coinChangeWays(coins, amount) {\n    const dp = Array(amount + 1).fill(0);\n    dp[0] = 1;\n    \n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}\n\n// Example usage\nconst coins = [1, 3, 4];\nconst amount = 6;\nconsole.log(`Minimum coins: ${coinChangeMin(coins, amount)}`);  // Output: 2\nconsole.log(`Number of ways: ${coinChangeWays(coins, amount)}`);  // Output: 5",
    "java": "public class CoinChange {\n    public static int coinChangeMin(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE - 1);\n        dp[0] = 0;\n        \n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n        \n        return dp[amount] == Integer.MAX_VALUE - 1 ? -1 : dp[amount];\n    }\n    \n    public static int coinChangeWays(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        \n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        return dp[amount];\n    }\n}",
    "cpp": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint coinChangeMin(vector<int>& coins, int amount) {\n    vector<int> dp(amount + 1, INT_MAX - 1);\n    dp[0] = 0;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = min(dp[i], dp[i - coin] + 1);\n        }\n    }\n    \n    return dp[amount] == INT_MAX - 1 ? -1 : dp[amount];\n}\n\nint coinChangeWays(vector<int>& coins, int amount) {\n    vector<int> dp(amount + 1, 0);\n    dp[0] = 1;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["dynamic-programming", "combinatorics", "optimization"]
  }
}