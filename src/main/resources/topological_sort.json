{
  "algorithm": {
    "id": "topological_sort",
    "name": "Topological Sort",
    "category": "Graph Algorithms / Ordering",
    "description": "A linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge u → v, vertex u comes before v in the ordering. Used to schedule tasks with dependencies."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're getting dressed in the morning. You have dependencies: you need to wear underwear before pants, socks before shoes, shirt before jacket. A topological sort would give you a valid order like: underwear → socks → pants → shoes → shirt → jacket. This ensures you never try to put something on that depends on something you haven't put on yet."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Topological sort arranges vertices in a directed acyclic graph (DAG) in a linear order where all dependencies are satisfied. If the graph has a cycle, topological sort is impossible.\n\n**Key Idea:** Process vertices that have no incoming edges (dependencies) first, then remove them and repeat. This can be done using DFS (post-order traversal) or Kahn's algorithm (BFS-based)."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[\"Start Topological Sort\"] --> B{\"Choose Algorithm\"}\n    B --> C[\"Kahn's Algorithm BFS-based\"]\n    B --> D[\"DFS-based Algorithm\"]\n    \n    C --> E[\"Calculate in-degree for all vertices\"]\n    E --> F[\"Initialize queue with vertices having in-degree 0\"]\n    F --> G{\"Queue empty?\"}\n    G -->|No| H[\"Dequeue vertex u, add to result\"]\n    H --> I[\"For each neighbor v of u\"]\n    I --> J[\"Decrement in-degree of v\"]\n    J --> K{\"in-degreev == 0?\"}\n    K -->|Yes| L[\"Enqueue v\"]\n    K -->|No| M[\"Continue\"]\n    L --> N{\"More neighbors?\"}\n    M --> N\n    N -->|Yes| I\n    N -->|No| G\n    G -->|Yes| O{\"Result size == V?\"}\n    \n    D --> P[\"Perform DFS on all unvisited vertices\"]\n    P --> Q[\"Mark vertex as visited\"]\n    Q --> R[\"Recursively visit all unvisited neighbors\"]\n    R --> S[\"Add vertex to result after visiting neighbors\"]\n    S --> T{\"All vertices visited?\"}\n    T -->|No| P\n    T -->|Yes| U[\"Reverse result\npost-order gives reverse topological order\"]\n    \n    O -->|Yes| V[\"Valid topological order found\"]\n    O -->|No| W[\"Graph has cycle\nNo topological order\"]\n    U --> V\n    V --> X[\"Return topological order\"]\n    W --> X\n    X --> Y[\"End\"]\n```"
    },
    {
      "id": "example",
      "label": "Example Problem",
      "content": "**Course Prerequisites DAG:**\n```\nMath101 → Phys101 → Phys201\nMath101 → CS101 → CS201\nCS101 → CS301\nPhys101 → CS301\n```\n\n**Graph Representation:**\n- Vertices: Math101, Phys101, Phys201, CS101, CS201, CS301\n- Edges: \n  - Math101 → Phys101, Math101 → CS101\n  - Phys101 → Phys201, Phys101 → CS301\n  - CS101 → CS201, CS101 → CS301\n\n**Topological Sort using Kahn's Algorithm:**\n\n| Step | Queue | In-degrees | Result |\n|------|-------|------------|---------|\n| 0 | [Math101] | Math101:0, Phys101:1, CS101:1, Phys201:1, CS201:1, CS301:2 | [] |\n| 1 | Process Math101 | Phys101:0, CS101:0 | [Math101] |\n| 2 | [Phys101, CS101] | - | [Math101] |\n| 3 | Process Phys101 | Phys201:0, CS301:1 | [Math101, Phys101] |\n| 4 | [CS101, Phys201] | - | [Math101, Phys101] |\n| 5 | Process CS101 | CS201:0, CS301:0 | [Math101, Phys101, CS101] |\n| 6 | [Phys201, CS201, CS301] | - | [Math101, Phys101, CS101] |\n| 7 | Process Phys201 | - | [Math101, Phys101, CS101, Phys201] |\n| 8 | Process CS201 | - | [Math101, Phys101, CS101, Phys201, CS201] |\n| 9 | Process CS301 | - | [Math101, Phys101, CS101, Phys201, CS201, CS301] |\n\n**Valid Topological Orders:**\n- Math101 → Phys101 → CS101 → Phys201 → CS201 → CS301\n- Math101 → CS101 → Phys101 → CS201 → Phys201 → CS301\n- Math101 → Phys101 → CS101 → Phys201 → CS301 → CS201\n\n**Note:** Multiple valid orders exist for the same DAG."
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **O(V + E)** - for both Kahn's and DFS-based algorithms\n\n### Space Complexity:\n- **O(V)** - for storing in-degrees, queue/stack, and result\n\n### Requirements:\n- **Directed Acyclic Graph (DAG)** - no cycles allowed\n- **Directed edges** represent dependencies\n\n### Uniqueness:\n- **Not unique** - a DAG can have multiple valid topological orders\n\n### When to Use Topological Sort:\n\n**✅ Suitable for:**\n- Task scheduling with dependencies\n- Build systems (make, maven, gradle)\n- Course prerequisite planning\n- Event scheduling\n- Instruction scheduling in compilers\n- Pipeline processing\n\n**❌ Not suitable for:**\n- Graphs with cycles\n- Undirected graphs\n- When order doesn't matter\n\n### Variations:\n1. **Kahn's Algorithm** - BFS-based, detects cycles\n2. **DFS-based** - uses post-order traversal\n3. **All Topological Sorts** - generates all possible orders\n4. **Lexicographical Topological Sort** - chooses smallest vertex first\n\n### Cycle Detection:\n- **Kahn's algorithm** naturally detects cycles (result size < V)\n- **DFS-based** can detect cycles with recursion stack\n\n### Optimization Tips:\n1. **Use Kahn's algorithm** for cycle detection\n2. **Use DFS-based** when you need all possible orders\n3. **Maintain zero-in-degree set** for efficient selection\n4. **Use priority queue** for lexicographical order\n\n### Common Applications:\n1. **Build Systems** - compiling source files in dependency order\n2. **Course Scheduling** - arranging courses with prerequisites\n3. **Task Scheduling** - managing dependent tasks\n4. **Package Management** - resolving dependencies\n5. **Compiler Optimization** - instruction scheduling\n6. **Data Processing** - ETL pipeline dependencies"
    }
  ],
  "code_examples": {
    "python": "from collections import deque, defaultdict\n\ndef topological_sort_kahn(graph):\n    \"\"\"\n    Kahn's algorithm for topological sort\n    graph: dict {vertex: list of neighbors}\n    returns: topological order or None if cycle exists\n    \"\"\"\n    # Calculate in-degree for each vertex\n    in_degree = defaultdict(int)\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    \n    # Initialize queue with vertices having 0 in-degree\n    queue = deque([u for u in graph if in_degree[u] == 0])\n    topo_order = []\n    \n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        \n        # Decrease in-degree of neighbors\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    # Check for cycle\n    if len(topo_order) != len(graph):\n        return None  # Cycle exists\n    \n    return topo_order\n\ndef topological_sort_dfs(graph):\n    \"\"\"\n    DFS-based topological sort\n    graph: dict {vertex: list of neighbors}\n    returns: topological order or None if cycle exists\n    \"\"\"\n    visited = set()\n    recursion_stack = set()\n    result = []\n    \n    def dfs(u):\n        if u in recursion_stack:\n            return False  # Cycle detected\n        if u in visited:\n            return True\n        \n        visited.add(u)\n        recursion_stack.add(u)\n        \n        for v in graph.get(u, []):\n            if not dfs(v):\n                return False\n        \n        recursion_stack.remove(u)\n        result.append(u)\n        return True\n    \n    for u in graph:\n        if u not in visited:\n            if not dfs(u):\n                return None  # Cycle exists\n    \n    return result[::-1]  # Reverse for topological order\n\ndef all_topological_sorts(graph):\n    \"\"\"\n    Generate all possible topological orders\n    \"\"\"\n    in_degree = defaultdict(int)\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    \n    visited = set()\n    result = []\n    \n    def backtrack(current_order, current_in_degree):\n        if len(current_order) == len(graph):\n            result.append(current_order[:])\n            return\n        \n        for u in graph:\n            if u not in visited and current_in_degree[u] == 0:\n                visited.add(u)\n                current_order.append(u)\n                \n                # Update in-degrees of neighbors\n                for v in graph[u]:\n                    current_in_degree[v] -= 1\n                \n                backtrack(current_order, current_in_degree)\n                \n                # Backtrack\n                for v in graph[u]:\n                    current_in_degree[v] += 1\n                current_order.pop()\n                visited.remove(u)\n    \n    backtrack([], in_degree.copy())\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    # Course prerequisites graph\n    graph = {\n        'Math101': ['Phys101', 'CS101'],\n        'Phys101': ['Phys201', 'CS301'],\n        'CS101': ['CS201', 'CS301'],\n        'Phys201': [],\n        'CS201': [],\n        'CS301': []\n    }\n    \n    print(\"Kahn's Topological Sort:\")\n    print(topological_sort_kahn(graph))\n    \n    print(\"\\nDFS-based Topological Sort:\")\n    print(topological_sort_dfs(graph))\n    \n    print(\"\\nAll Topological Sorts:\")\n    all_sorts = all_topological_sorts(graph)\n    for i, order in enumerate(all_sorts[:3], 1):  # Show first 3\n        print(f\"{i}: {order}\")",
    "javascript": "function topologicalSortKahn(graph) {\n    const inDegree = new Map();\n    const queue = [];\n    const topoOrder = [];\n    \n    // Initialize in-degree and find vertices with 0 in-degree\n    for (const u in graph) {\n        inDegree.set(u, 0);\n    }\n    \n    for (const u in graph) {\n        for (const v of graph[u]) {\n            inDegree.set(v, (inDegree.get(v) || 0) + 1);\n        }\n    }\n    \n    for (const [u, degree] of inDegree) {\n        if (degree === 0) {\n            queue.push(u);\n        }\n    }\n    \n    while (queue.length > 0) {\n        const u = queue.shift();\n        topoOrder.push(u);\n        \n        for (const v of graph[u] || []) {\n            inDegree.set(v, inDegree.get(v) - 1);\n            if (inDegree.get(v) === 0) {\n                queue.push(v);\n            }\n        }\n    }\n    \n    // Check for cycle\n    if (topoOrder.length !== Object.keys(graph).length) {\n        return null; // Cycle exists\n    }\n    \n    return topoOrder;\n}\n\nfunction topologicalSortDFS(graph) {\n    const visited = new Set();\n    const recursionStack = new Set();\n    const result = [];\n    \n    function dfs(u) {\n        if (recursionStack.has(u)) {\n            return false; // Cycle detected\n        }\n        if (visited.has(u)) {\n            return true;\n        }\n        \n        visited.add(u);\n        recursionStack.add(u);\n        \n        for (const v of graph[u] || []) {\n            if (!dfs(v)) {\n                return false;\n            }\n        }\n        \n        recursionStack.delete(u);\n        result.push(u);\n        return true;\n    }\n    \n    for (const u in graph) {\n        if (!visited.has(u)) {\n            if (!dfs(u)) {\n                return null; // Cycle exists\n            }\n        }\n    }\n    \n    return result.reverse();\n}\n\n// Example usage\nconst graph = {\n    'Math101': ['Phys101', 'CS101'],\n    'Phys101': ['Phys201', 'CS301'],\n    'CS101': ['CS201', 'CS301'],\n    'Phys201': [],\n    'CS201': [],\n    'CS301': []\n};\n\nconsole.log(\"Kahn's Topological Sort:\");\nconsole.log(topologicalSortKahn(graph));\n\nconsole.log(\"\\nDFS-based Topological Sort:\");\nconsole.log(topologicalSortDFS(graph));",
    "java": "import java.util.*;\n\npublic class TopologicalSort {\n    \n    // Kahn's algorithm\n    public static List<String> topologicalSortKahn(Map<String, List<String>> graph) {\n        Map<String, Integer> inDegree = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n        List<String> result = new ArrayList<>();\n        \n        // Initialize in-degree\n        for (String u : graph.keySet()) {\n            inDegree.put(u, 0);\n        }\n        \n        // Calculate in-degree\n        for (String u : graph.keySet()) {\n            for (String v : graph.get(u)) {\n                inDegree.put(v, inDegree.getOrDefault(v, 0) + 1);\n            }\n        }\n        \n        // Add vertices with 0 in-degree to queue\n        for (String u : inDegree.keySet()) {\n            if (inDegree.get(u) == 0) {\n                queue.offer(u);\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            String u = queue.poll();\n            result.add(u);\n            \n            for (String v : graph.get(u)) {\n                inDegree.put(v, inDegree.get(v) - 1);\n                if (inDegree.get(v) == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        \n        // Check for cycle\n        if (result.size() != graph.size()) {\n            return null;\n        }\n        \n        return result;\n    }\n    \n    // DFS-based topological sort\n    public static List<String> topologicalSortDFS(Map<String, List<String>> graph) {\n        Set<String> visited = new HashSet<>();\n        Set<String> recursionStack = new HashSet<>();\n        List<String> result = new ArrayList<>();\n        \n        for (String u : graph.keySet()) {\n            if (!visited.contains(u)) {\n                if (!dfs(u, graph, visited, recursionStack, result)) {\n                    return null; // Cycle detected\n                }\n            }\n        }\n        \n        Collections.reverse(result);\n        return result;\n    }\n    \n    private static boolean dfs(String u, Map<String, List<String>> graph, \n                              Set<String> visited, Set<String> recursionStack, \n                              List<String> result) {\n        if (recursionStack.contains(u)) {\n            return false; // Cycle detected\n        }\n        if (visited.contains(u)) {\n            return true;\n        }\n        \n        visited.add(u);\n        recursionStack.add(u);\n        \n        for (String v : graph.get(u)) {\n            if (!dfs(v, graph, visited, recursionStack, result)) {\n                return false;\n            }\n        }\n        \n        recursionStack.remove(u);\n        result.add(u);\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Map<String, List<String>> graph = new HashMap<>();\n        graph.put(\"Math101\", Arrays.asList(\"Phys101\", \"CS101\"));\n        graph.put(\"Phys101\", Arrays.asList(\"Phys201\", \"CS301\"));\n        graph.put(\"CS101\", Arrays.asList(\"CS201\", \"CS301\"));\n        graph.put(\"Phys201\", new ArrayList<>());\n        graph.put(\"CS201\", new ArrayList<>());\n        graph.put(\"CS301\", new ArrayList<>());\n        \n        System.out.println(\"Kahn's Topological Sort:\");\n        System.out.println(topologicalSortKahn(graph));\n        \n        System.out.println(\"\\nDFS-based Topological Sort:\");\n        System.out.println(topologicalSortDFS(graph));\n    }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<string> topologicalSortKahn(unordered_map<string, vector<string>>& graph) {\n    unordered_map<string, int> inDegree;\n    queue<string> q;\n    vector<string> result;\n    \n    // Initialize in-degree\n    for (auto& pair : graph) {\n        inDegree[pair.first] = 0;\n    }\n    \n    // Calculate in-degree\n    for (auto& pair : graph) {\n        for (string v : pair.second) {\n            inDegree[v]++;\n        }\n    }\n    \n    // Add vertices with 0 in-degree to queue\n    for (auto& pair : inDegree) {\n        if (pair.second == 0) {\n            q.push(pair.first);\n        }\n    }\n    \n    while (!q.empty()) {\n        string u = q.front();\n        q.pop();\n        result.push_back(u);\n        \n        for (string v : graph[u]) {\n            inDegree[v]--;\n            if (inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n    \n    // Check for cycle\n    if (result.size() != graph.size()) {\n        return {}; // Cycle exists\n    }\n    \n    return result;\n}\n\nbool dfs(string u, unordered_map<string, vector<string>>& graph,\n         unordered_map<string, bool>& visited,\n         unordered_map<string, bool>& recursionStack,\n         vector<string>& result) {\n    if (recursionStack[u]) return false;\n    if (visited[u]) return true;\n    \n    visited[u] = true;\n    recursionStack[u] = true;\n    \n    for (string v : graph[u]) {\n        if (!dfs(v, graph, visited, recursionStack, result)) {\n            return false;\n        }\n    }\n    \n    recursionStack[u] = false;\n    result.push_back(u);\n    return true;\n}\n\nvector<string> topologicalSortDFS(unordered_map<string, vector<string>>& graph) {\n    unordered_map<string, bool> visited;\n    unordered_map<string, bool> recursionStack;\n    vector<string> result;\n    \n    for (auto& pair : graph) {\n        if (!visited[pair.first]) {\n            if (!dfs(pair.first, graph, visited, recursionStack, result)) {\n                return {}; // Cycle detected\n            }\n        }\n    }\n    \n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    unordered_map<string, vector<string>> graph = {\n        {\"Math101\", {\"Phys101\", \"CS101\"}},\n        {\"Phys101\", {\"Phys201\", \"CS301\"}},\n        {\"CS101\", {\"CS201\", \"CS301\"}},\n        {\"Phys201\", {}},\n        {\"CS201\", {}},\n        {\"CS301\", {}}\n    };\n    \n    cout << \"Kahn's Topological Sort:\" << endl;\n    vector<string> result = topologicalSortKahn(graph);\n    for (string s : result) {\n        cout << s << \" \";\n    }\n    cout << endl;\n    \n    cout << \"\\nDFS-based Topological Sort:\" << endl;\n    result = topologicalSortDFS(graph);\n    for (string s : result) {\n        cout << s << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["graph", "ordering", "dag", "dependencies", "scheduling"]
  }
}